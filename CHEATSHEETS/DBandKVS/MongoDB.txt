連番は行クラスサンプル
require "mongo"
 
class MongoSequence
 
class << self
attr_writer :database
 
def database
return @database if @database
return MongoMapper.database if defined?(MongoMapper) &&
MongoMapper.database
#mongoid3
# return Mongoid.database if defined?(Mongoid) && Mongoid.database
if Mongoid.respond_to?(:database)
#mongoid3
return Mongoid.database
else
#mongoid4
return Mongoid::Config.sessions[:default][:database]
end
end
 
def collection
#mongoid3
database['sequences']
#mongoid4
# byebug
# Mongoid.default_session.use("bukken_api_it")['sequences']
end
 
def [](name)
new(name)
end
 
def []=(name, integer)
self[name].current = integer
end
end
 
attr_reader :name
 
def initialize(name)
@name = name.to_s
end
 
def collection
MongoSequence.collection
end
 
def next
current_after_update(:$inc => { :current => 1 })
end
 
def current
current_after_update(:$set => {}) # noop that works
end
 
def current=(integer)
current_after_update(:current => integer)
end
 
private
 
def current_after_update(update)
options = {
:query => { :_id => name },
:new => true, # return the modified doc
:update => update
}
# Mongoid.default_session.use("bukken_api_it")['sequences']
# coll = collection.find_and_modify(options)
aaa = Bukken.mongo_session.use("bukken_api_it")['sequences']
# byebug
coll = Bukken.find_and_modify(options)
if coll
coll['current']
else
raise Mongo::OperationFailure, 'No matching object found'
end
rescue Mongo::OperationFailure => e
raise unless e.message =~ /No matching object found/
init_in_database
current_after_update(update)
end
 
def init_in_database
collection.save({:_id => na
mongo版bullet
embedded_in
embeds_many
embeds_one
#methods
	.exists
	.distinct?
	db.bukken.find({name:{$regex:’_date$’}})
	db.bukken.find({},{'toroku_date':true});
	db.bukken.find({},{ name: "toroku_date", toroku_date: true });
	db.bukken.find({}, {'kokai_koshin_date':true} );
	#演算子
		比較条件
		.in, .not_in,
		.any_of ( (cond-formula 1),(cond2-formula))
		.ne,.
		.gt, .lt,
#query embedded docs
	.where ('attr' = ($ne = value))
#Mongoid commands
	Bukken.where(:sakimono_date.ne => nil).limit(1)
	Bukken.where(:sakimono_date.ne => nil).last[:sakimono_date]
	new Date('2014-3-27')
	new Date(Date.now()).toLocaleTimeString()
