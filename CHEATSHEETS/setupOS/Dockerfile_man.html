

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Dockerfile リファレンス &mdash; Docker-docs-ja 17.06.Beta ドキュメント</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="author" title="このドキュメントについて"
              href="../../about.html"/>
        <link rel="index" title="索引"
              href="../../genindex.html"/>
        <link rel="search" title="検索" href="../../search.html"/>
    <link rel="top" title="Docker-docs-ja 17.06.Beta ドキュメント" href="../../index.html"/>
        <link rel="up" title="Engine リファレンス" href="index.html"/>
        <link rel="next" title="Docker run リファレンス" href="run.html"/>
        <link rel="prev" title="Engine リファレンス" href="index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Docker-docs-ja
          

          
          </a>

          
            
            
              <div class="version">
                17.06.Beta
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Glossary - 用語集</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">用語集</a></li>
</ul>
<p class="caption"><span class="caption-text">Guide - ガイド</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation/toc.html">Get Docker - Docker を手に入れる</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get-started/toc.html">Get started - 始めましょう</a></li>
</ul>
<p class="caption"><span class="caption-text">Docker Engine</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../toc.html">Docker Engine</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html">Docker Engine について</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/index.html">例で学ぶ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../userguide/index.html">Docker Engine ユーザガイド</a></li>
<li class="toctree-l2"><a class="reference internal" href="../admin/index.html">管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/toc.html">安全な Engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../extend/toc.html">Engine の拡張</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/toc.html">アプリケーションの Docker 化</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Engine リファレンス</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Dockerfile リファレンス</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">使い方</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">書式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parser-directive">パーサ・ディレクティブ（parser directive）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#environment-replacement">環境変数の置き換え</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dockerignore">.dockerignore ファイル</a></li>
<li class="toctree-l4"><a class="reference internal" href="#from">FROM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maintainer">MAINTAINER</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run">RUN</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cmd">CMD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#label">LABEL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expose">EXPOSE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#env">ENV</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add">ADD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#copy">COPY</a></li>
<li class="toctree-l4"><a class="reference internal" href="#entrypoint">ENTRYPOINT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cmd-entrypoint">CMD と ENTRYPOINT がどのように作用するか学ぶ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#volume">VOLUME</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user">USER</a></li>
<li class="toctree-l4"><a class="reference internal" href="#workdir">WORKDIR</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arg">ARG</a></li>
<li class="toctree-l4"><a class="reference internal" href="#onbuild">ONBUILD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stopsignal">STOPSIGNAL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#healthcheck">HEALTHCHECK</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shell">SHELL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">Dockerfile の例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="run.html">Docker run リファレンス</a></li>
<li class="toctree-l3"><a class="reference internal" href="commandline/toc.html">コマンドライン・リファレンス</a></li>
<li class="toctree-l3"><a class="reference internal" href="api/toc.html">API リファレンス</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../migration.html">Engine 1.10 への移行</a></li>
<li class="toctree-l2"><a class="reference internal" href="../breaking_changes.html">破壊的変更</a></li>
<li class="toctree-l2"><a class="reference internal" href="../deprecated.html">廃止機能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html">よくある質問と回答(FAQ)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../swarm/toc.html">Swarm管理(1.12RC)</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Docker Compose</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../compose/toc.html">Docker Compose</a></li>
</ul>
<p class="caption"><span class="caption-text">Docker Hub</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../docker-hub/index.html">Docker Hub</a></li>
</ul>
<p class="caption"><span class="caption-text">Docker Machine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../machine/index.html">Docker Machine</a></li>
</ul>
<p class="caption"><span class="caption-text">Docker Toolbox</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../toolbox/index.html">Docker Toolbox</a></li>
</ul>
<p class="caption"><span class="caption-text">コンポーネント・プロジェクト</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../registry/toc.html">Docker Registry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../swarm/toc.html">Docker Swarm</a></li>
</ul>
<p class="caption"><span class="caption-text">Docker について</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../release-notes.html">リリース・ノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">用語集</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">日本語版について</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guide.html">Docker ドキュメント逆引きガイド</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pdf-download.html">Docker ドキュメント日本語版 PDF ダウンロード</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Docker-docs-ja</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
        <li><a href="../toc.html">Docker Engine</a> &raquo;</li>
      
        <li><a href="index.html">Engine リファレンス</a> &raquo;</li>
      
    <li>Dockerfile リファレンス</li>
    <li class="wy-breadcrumbs-aside">
      
          <a href="https://github.com/zembutsu/docs.docker.jp/blob/master/engine/reference/builder.rst" class="fa fa-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dockerfile">
<h1>Dockerfile リファレンス<a class="headerlink" href="#dockerfile" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="sidebar">
<p class="first sidebar-title">目次</p>
<div class="contents local last topic" id="id1">
<ul class="simple">
<li><a class="reference internal" href="#id2" id="id27">使い方</a></li>
<li><a class="reference internal" href="#id3" id="id28">書式</a></li>
<li><a class="reference internal" href="#parser-directive" id="id29">パーサ・ディレクティブ（parser directive）</a><ul>
<li><a class="reference internal" href="#escape" id="id30">escape</a></li>
</ul>
</li>
<li><a class="reference internal" href="#environment-replacement" id="id31">環境変数の置き換え</a></li>
<li><a class="reference internal" href="#dockerignore" id="id32">.dockerignore ファイル</a></li>
<li><a class="reference internal" href="#from" id="id33">FROM</a></li>
<li><a class="reference internal" href="#maintainer" id="id34">MAINTAINER</a></li>
<li><a class="reference internal" href="#run" id="id35">RUN</a><ul>
<li><a class="reference internal" href="#id8" id="id36">既知の問題(RUN)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cmd" id="id37">CMD</a></li>
<li><a class="reference internal" href="#label" id="id38">LABEL</a></li>
<li><a class="reference internal" href="#expose" id="id39">EXPOSE</a></li>
<li><a class="reference internal" href="#env" id="id40">ENV</a></li>
<li><a class="reference internal" href="#add" id="id41">ADD</a></li>
<li><a class="reference internal" href="#copy" id="id42">COPY</a></li>
<li><a class="reference internal" href="#entrypoint" id="id43">ENTRYPOINT</a><ul>
<li><a class="reference internal" href="#exec-entrypoint" id="id44">exec 形式の ENTRYPOINT 例</a></li>
<li><a class="reference internal" href="#id18" id="id45">シェル形式の ENTRYPOINT 例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cmd-entrypoint" id="id46">CMD と ENTRYPOINT がどのように作用するか学ぶ</a></li>
<li><a class="reference internal" href="#volume" id="id47">VOLUME</a></li>
<li><a class="reference internal" href="#user" id="id48">USER</a></li>
<li><a class="reference internal" href="#workdir" id="id49">WORKDIR</a></li>
<li><a class="reference internal" href="#arg" id="id50">ARG</a><ul>
<li><a class="reference internal" href="#impact-on-build-caching" id="id51">構築キャッシュの影響</a></li>
</ul>
</li>
<li><a class="reference internal" href="#onbuild" id="id52">ONBUILD</a></li>
<li><a class="reference internal" href="#stopsignal" id="id53">STOPSIGNAL</a></li>
<li><a class="reference internal" href="#healthcheck" id="id54">HEALTHCHECK</a></li>
<li><a class="reference internal" href="#shell" id="id55">SHELL</a></li>
<li><a class="reference internal" href="#id26" id="id56">Dockerfile の例</a></li>
</ul>
</div>
</div>
<p>Docker は <code class="docutils literal"><span class="pre">Dockerfile</span></code> から命令を読み込み、自動的にイメージを構築できます。 <code class="docutils literal"><span class="pre">Dockerfile</span></code> はテキスト形式のドキュメントであり、コマンドライン上でイメージを作り上げる命令を全て記述します。ユーザは <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span></code> を使い、複数のコマンド行の命令を順次実行し、イメージを自動構築します。</p>
<p>このページでは <code class="docutils literal"><span class="pre">Dockerfile</span></code> 内で利用可能な命令を説明します。ページを読み終えたら、より便利に使うための <code class="docutils literal"><span class="pre">Dockerfile</span></code> の <a class="reference internal" href="../userguide/eng-image/dockerfile_best-practice.html"><span class="doc">ベスト・プラクティス</span></a> もご覧ください。</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id27">使い方</a><a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span></code> コマンドは <code class="docutils literal"><span class="pre">Dockerfile</span></code> と <em>コンテクスト(context；イメージに含まれる「内容」の意味)</em> に従ってイメージを構築します。構築用コンテクストとは、ファイルを示す <code class="docutils literal"><span class="pre">PATH</span></code>  や <code class="docutils literal"><span class="pre">URL</span></code> の場所です。 <code class="docutils literal"><span class="pre">PATH</span></code> はローカルのファイルシステム上のディレクトリです。 <code class="docutils literal"><span class="pre">URL</span></code> は Git リポジトリの場所です。</p>
<p>コンテクストの処理は再帰的です。そのため、 <code class="docutils literal"><span class="pre">PATH</span></code> にはサブディレクトリを含みます。また <code class="docutils literal"><span class="pre">URL</span></code> であればリポジトリと、そのサブモジュールも含みます。単に build コマンドを実行したら、現在のディレクトリをコンテクストとして使います。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker build .
Sending build context to Docker daemon  <span class="m">6</span>.51 MB
...
</pre></div>
</div>
<p>構築を処理するのは Docker デーモンであり、 CLI ではありません。まずはじめの構築プロセスは、対象のコンテクスト（再帰的）をデーモンに送信することです。多くの場合、空のディレクトリをコンテクストとして使いますので、Dockerfile をそのディレクトリ設置できます。Dockerfile の構築に必要なファイルのみを（ディレクトリに）追加します。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><code class="docutils literal"><span class="pre">PATH</span></code> として自分のルート・ディレクトリ <code class="docutils literal"><span class="pre">/</span></code> を使わないでください。これは、自分のハードディスクに含まれる内容を、Docker デーモンに転送しようとするためです。</p>
</div>
<p><code class="docutils literal"><span class="pre">Dockerfile</span></code> に記述した <code class="docutils literal"><span class="pre">COPY</span></code> 命令などで使うファイル指定を参照し、コンテクスト（内容物の意味）を構築します。構築パフォーマンスを向上するためには、 <code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルにファイルやディレクトリを追加し、コンテクスト・ディレクトリから除外できます。より詳しい情報は、 <a class="reference internal" href="#dockerignore-file"><span class="std std-ref">.dockerignore ファイルの作成</span></a> をご覧ください。</p>
<p>伝統的に <code class="docutils literal"><span class="pre">Dockerfile</span></code> は、<code class="docutils literal"><span class="pre">Dockerfile</span></code> とコンテクストがあるルートの場所を示します。 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span></code> 時に <code class="docutils literal"><span class="pre">-f</span></code> フラグを使えば、システム上のどこに Dockerfile があるか指定できます。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker build -f /path/to/a/Dockerfile .
</pre></div>
</div>
<p>新しいイメージの構築に成功する時は、新しいイメージにリポジトリとタグを指定できます。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker build -t shykes/myapp .
</pre></div>
</div>
<p>Docker デーモンは <code class="docutils literal"><span class="pre">Dockerfile</span></code> の命令を1行ずつ実行し、必要があれば命令ごとにイメージをコミットし、最終的に新しいイメージ ID を出力します。Docker デーモンは送信したコンテクストを自動的に削除します。</p>
<p>各命令は独立して実行されるのでご注意ください。新しいイメージの作成時、 <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">cd</span> <span class="pre">/tmp</span></code> を実行したとしても、次の命令には何ら影響を与えません。</p>
<p>Docker は可能であればいつでも中間イメージ（キャッシュ）を再利用します。これは <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span></code> 処理を速くするためです。コンソール出力に <code class="docutils literal"><span class="pre">Using</span> <span class="pre">cache</span></code> （キャッシュを利用中）の文字列が表示されます。より詳しい情報は <code class="docutils literal"><span class="pre">Dockerfile</span></code> ベスト・プラクティス・ガイドの <a class="reference internal" href="../userguide/eng-image/dockerfile_best-practice.html#build-cache"><span class="std std-ref">構築キャッシュ</span></a> をご覧ください。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker build -t svendowideit/ambassador .
Sending build context to Docker daemon <span class="m">15</span>.36 kB
Step <span class="m">0</span> : FROM alpine:3.2
 ---&gt; 31f630c65071
Step <span class="m">1</span> : MAINTAINER SvenDowideit@home.org.au
 ---&gt; Using cache
 ---&gt; 2a1c91448f5f
Step <span class="m">2</span> : RUN apk update <span class="o">&amp;&amp;</span>      apk add socat <span class="o">&amp;&amp;</span>        rm -r /var/cache/
 ---&gt; Using cache
 ---&gt; 21ed6e7fbb73
Step <span class="m">3</span> : CMD env <span class="p">|</span> grep <span class="nv">_TCP</span><span class="o">=</span> <span class="p">|</span> sed <span class="s1">&#39;s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/&#39;</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="nb">wait</span><span class="o">)</span> <span class="p">|</span> sh
 ---&gt; Using cache
 ---&gt; 7ea8aef582cc
Successfully built 7ea8aef582cc
</pre></div>
</div>
<p>構築が終わったら、<span class="xref std std-doc">レジストリにリポジトリを送信</span> する準備が整います。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id28">書式</a><a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ここでは <code class="docutils literal"><span class="pre">Dockerfile</span></code> の書式を説明します。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># コメント</span>
命令 引数
</pre></div>
</div>
<p>命令（instruction）は大文字と小文字を区別しません。しかし引数（arguments）を簡単に見分けられるよう、大文字にするのが便利です。</p>
<p>Docker は <code class="docutils literal"><span class="pre">Dockerfile</span></code> の命令を順番に実行します。イメージ構築にあたり <a class="reference internal" href="../../glossary.html#base-image"><span class="std std-ref">ベース・イメージ</span></a> を指定するため、 <strong>１行めの命令は「FROM」であるべき</strong> です。</p>
<p>Docker は有効な <a class="reference internal" href="#parser-directives"><span class="std std-ref">パーサ・ディレクティブ</span></a> でなければ、 <code class="docutils literal"><span class="pre">#</span></code> で <em>始まる</em> 行をコメントとみなします。 <code class="docutils literal"><span class="pre">#</span></code> マークは行における以降の文字をコメントとみなします。コメントは次のような書き方ができます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># コメント</span>
<span class="k">RUN</span> <span class="nb">echo</span> <span class="s1">&#39;良い感じもの何かを # 実行しています&#39;</span>
</pre></div>
</div>
<p>行中で命令の文字列が継続している場合は、コメント扱いしません。</p>
</div>
<div class="section" id="parser-directive">
<span id="parser-directives"></span><h2><a class="toc-backref" href="#id29">パーサ・ディレクティブ（parser directive）</a><a class="headerlink" href="#parser-directive" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>パーサ・ディレクティブはオプションです。 <code class="docutils literal"><span class="pre">Dockerfile</span></code> 中では、次に続く行にも影響を与えます。パーサ・ディレクティブは構築時にレイヤを追加しませんので、構築ステップでは表示されません。パーサ・ディレクティブは <code class="docutils literal"><span class="pre">#</span> <span class="pre">ディレクティブ=値</span></code> という特別な種類のコメントとして記述します。１つのディレクティブは１度しか使われません。</p>
<p>コメントがあれば、空行または構築命令があったとしても、 Docker はパーサ・ディレクティブを探しません。そのかわり、あらゆる書式をパーサ・ディレクティブではなくコメントとみなすため、有効なパーサ・ディレクティブとはみなしません。そのため、全てのパーサ・ディレクティブは <code class="docutils literal"><span class="pre">Dockerfile</span></code>  の限りなく上に書くべきです。</p>
<p>パーサ・ディレクティブは大文字と小文字を区別しません。しかしながら、小文字での記述が便利です。パーサ・ディレクティブの後に空白行を入れるのも便利です。行を継続する文字列は、パーサ・ディレクティブではサポートされません。</p>
<p>これらのルールがあるため、以下の例は全て無効です。</p>
<p>行の継続は無効：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># direc \</span>
<span class="nv">tive</span><span class="o">=</span>value
</pre></div>
</div>
<p>２つ並ぶ場合は無効：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># directive=value1</span>
<span class="c"># directive=value2</span>

<span class="k">FROM</span><span class="s"> ImageName</span>
</pre></div>
</div>
<p>構築命令の後にあれば、コメントとして扱う：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ImageName</span>
<span class="c"># directive=value</span>
</pre></div>
</div>
<p>パーサ・ディレクティブでないコメントがあれば、以降のものはコメントとして扱う：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># About my dockerfile</span>
<span class="k">FROM</span><span class="s"> ImageName</span>
<span class="c"># directive=value</span>
</pre></div>
</div>
<p>不明なディレクティブは認識できないため、コメントとして扱う。さらに、パーサ・ディレクティブではないコメントの後にディレクティブがあったとしても、コメントとして扱う：</p>
<p># unknowndirective=value
# knowndirective=value</p>
<p>行を壊さない空白行はパーサ・ディレクティブとして使えます。従って、以下の行はすべて同一として扱う：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c">#directive=value</span>
<span class="c"># directive =value</span>
<span class="c">#   directive= value</span>
<span class="c"># directive = value</span>
<span class="c">#     dIrEcTiVe=value</span>
</pre></div>
</div>
<p>以下のパーサ・ディレクティブをサポートします：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">escape</span></code></li>
</ul>
<div class="section" id="escape">
<span id="parser-directive-escape"></span><h3><a class="toc-backref" href="#id30">escape</a><a class="headerlink" href="#escape" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># escape=\ (バックスラッシュ)</span>
</pre></div>
</div>
<p>または</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># escape=` (バッククォート)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">escape</span></code> ディレクティブは <code class="docutils literal"><span class="pre">Dockerfile</span></code> で使うエスケープ文字をセットします。指定しなければ、デフォルトのエスケープ文字は <code class="docutils literal"><span class="pre">\</span></code> です。</p>
<p>エスケープ文字を使うのは、行におけるエスケープ文字と、新しい行にエスケープする（つなげる）ための両方です。これにより、 <code class="docutils literal"><span class="pre">Dockerfile</span></code> の命令を複数行に記述できます。 <code class="docutils literal"><span class="pre">Dockerfile</span></code> で <code class="docutils literal"><span class="pre">escape</span></code> パーサ・ディレクティブを指定しなければ <code class="docutils literal"><span class="pre">RUN</span></code> 命令でもエスケープ処理はされませんが、行の最後は除くのでご注意ください。</p>
<p>エスケープ文字に 「`」 を指定するのは <code class="docutils literal"><span class="pre">Windows</span></code> 上で役立ちます。 <code class="docutils literal"><span class="pre">\</span></code> はディレクトリのパスのパーサ（区切り）だからです。 「`」 は <a class="reference external" href="https://technet.microsoft.com/en-us/library/hh847755.aspx">Windows PowerShell</a> で次の行をつなぎます。</p>
<p>以下では Windows では明確にエラーが出る例を考えます。２行目末尾の２つめの <code class="docutils literal"><span class="pre">\</span></code> は、１つめの <code class="docutils literal"><span class="pre">\</span></code> のエスケープとして処理されるのではなく、新しい行のためのエスケープとして扱われます。同様に３行目末尾の <code class="docutils literal"><span class="pre">\</span></code> は次の行に命令が継続するものとして扱われます。この dockerfile を使った結果、２行目と３行目は１つの命令として見なされます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>FROM windowsservercore
COPY testfile.txt c:\\
RUN dir c:\
</pre></div>
</div>
<p>実行結果：</p>
<div class="highlight-powershell"><div class="highlight"><pre><span></span>PS C:\John&gt; docker build -t cmd .
Sending build context to Docker daemon 3.072 kB
Step 1 : FROM windowsservercore
 ---&gt; dbfee88ee9fd
Step 2 : COPY testfile.txt c:RUN dir c:
GetFileAttributesEx c:RUN: The system cannot find the file specified.
PS C:\John&gt;
</pre></div>
</div>
<p>解決方法の１つは、 <code class="docutils literal"><span class="pre">COPY</span></code>  命令とディレクトリで <code class="docutils literal"><span class="pre">/</span></code> を使う方法です。しかしながら、構文上ベストなのは <code class="docutils literal"><span class="pre">Windows</span></code> 上のパスを普通に扱うことであり、最悪なのは <code class="docutils literal"><span class="pre">Windows</span></code> 上でパスの区切りとして <code class="docutils literal"><span class="pre">/</span></code> を指定するとエラーを起こしがちです。</p>
<p><code class="docutils literal"><span class="pre">escape</span></code> パーサ・ディレクティブを追加することで、次の <code class="docutils literal"><span class="pre">Dockerfile</span></code> は <code class="docutils literal"><span class="pre">Windows</span></code> 上のファイル・パスを期待通りに処理します。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span># escape=`

FROM windowsservercore
COPY testfile.txt c:\
RUN dir c:\
</pre></div>
</div>
<p>実行結果：</p>
<div class="highlight-powershell"><div class="highlight"><pre><span></span>PS C:\John&gt; docker build -t succeeds --no-cache=true .
Sending build context to Docker daemon 3.072 kB
Step 1 : FROM windowsservercore
 ---&gt; dbfee88ee9fd
Step 2 : COPY testfile.txt c:\
 ---&gt; 99ceb62e90df
Removing intermediate container 62afbe726221
Step 3 : RUN dir c:\
 ---&gt; Running in a5ff53ad6323
 Volume in drive C has no label.
 Volume Serial Number is 1440-27FA

 Directory of c:\

03/25/2016  05:28 AM    &lt;DIR&gt;          inetpub
03/25/2016  04:22 AM    &lt;DIR&gt;          PerfLogs
04/22/2016  10:59 PM    &lt;DIR&gt;          Program Files
03/25/2016  04:22 AM    &lt;DIR&gt;          Program Files (x86)
04/18/2016  09:26 AM                 4 testfile.txt
04/22/2016  10:59 PM    &lt;DIR&gt;          Users
04/22/2016  10:59 PM    &lt;DIR&gt;          Windows
               1 File(s)              4 bytes
               6 Dir(s)  21,252,689,920 bytes free
 ---&gt; 2569aa19abef
Removing intermediate container a5ff53ad6323
Successfully built 2569aa19abef
PS C:\John&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="environment-replacement">
<span id="id4"></span><h2><a class="toc-backref" href="#id31">環境変数の置き換え</a><a class="headerlink" href="#environment-replacement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Dockerfile</span></code> は環境変数（ <a class="reference internal" href="#env"><span class="std std-ref">env 命令</span></a> で宣言）も解釈できます。命令文字（ステートメント・リテラル）中では、変数の様な構文でエスケープ・シーケンスも扱えます。</p>
<p><code class="docutils literal"><span class="pre">Dockerfile</span></code> の中では、環境変数を <code class="docutils literal"><span class="pre">$variable_name</span></code> または <code class="docutils literal"><span class="pre">${variable_name}</span></code> の形式で記述します。これらは同等に扱われます。固定用の構文として典型的に使われるのは、空白スペースを変数名に入れず <code class="docutils literal"><span class="pre">${foo}_bar</span></code> のような変数名で割り当てることです。</p>
<p><code class="docutils literal"><span class="pre">${変数の_名前}</span></code> 構文は、次のような <code class="docutils literal"><span class="pre">bash</span></code> の変更をサポートしています。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">${変数:-文字}</span></code> は、 <code class="docutils literal"><span class="pre">変数</span></code> を設定したら、その値を使うことを意味します。もし <code class="docutils literal"><span class="pre">変数</span></code> がセットされ無ければ、 <code class="docutils literal"><span class="pre">文字</span></code> が設定されます。</li>
<li><code class="docutils literal"><span class="pre">${変数:+文字}</span></code> は、 <code class="docutils literal"><span class="pre">変数</span></code> を設定したら、<code class="docutils literal"><span class="pre">文字</span></code> を使います。 <code class="docutils literal"><span class="pre">変数</span></code> がセットされなければ、空白のままにします。</li>
</ul>
<p>いずれの場合でも、 <code class="docutils literal"><span class="pre">文字</span></code> とは何らかの文字列であり、追加の環境変数を含みます。</p>
<p>エスケープするには <code class="docutils literal"><span class="pre">\$foo</span></code> や <code class="docutils literal"><span class="pre">\${foo}</span></code> のように、変数名の前に <code class="docutils literal"><span class="pre">\</span></code> を付けます。例えば、 <code class="docutils literal"><span class="pre">$foo</span></code> と <code class="docutils literal"><span class="pre">${foo}</span></code> リテラルは別々のものです。</p>
<p>例（変数展開したものは、 <code class="docutils literal"><span class="pre">#</span></code> のあとに表示）：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> busybox</span>
<span class="k">ENV</span><span class="s"> foo /bar</span>
<span class="k">WORKDIR</span><span class="s"> ${foo}   # WORKDIR /bar</span>
<span class="k">ADD</span><span class="s"> . $foo       # ADD . /bar</span>
COPY <span class="se">\$</span>foo /quux # COPY <span class="nv">$foo</span> /quux
</pre></div>
</div>
<p>以下の命令で <code class="docutils literal"><span class="pre">Dockerfile</span></code> における環境変数の利用がサポートされています。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ADD</span></code></li>
<li><code class="docutils literal"><span class="pre">COPY</span></code></li>
<li><code class="docutils literal"><span class="pre">ENV</span></code></li>
<li><code class="docutils literal"><span class="pre">EXPOSE</span></code></li>
<li><code class="docutils literal"><span class="pre">LABEL</span></code></li>
<li><code class="docutils literal"><span class="pre">USER</span></code></li>
<li><code class="docutils literal"><span class="pre">WORKDIR</span></code></li>
<li><code class="docutils literal"><span class="pre">VOLUME</span></code></li>
<li><code class="docutils literal"><span class="pre">STOPSIGNAL</span></code></li>
</ul>
<p>同様に、</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ONBUILD</span></code> （上記の命令と組み合わせて使う場合にサポートされます）</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">1.4 より前のバージョンでは、環境変数における <code class="docutils literal"><span class="pre">ONBUILD</span></code> 命令と上記の命令の組み合わせはサポート <strong>していません</strong> 。</p>
</div>
<p>環境変数を使う代わりに、各変数をコマンド上で利用できます。次の例を見ましょう。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">ENV</span><span class="s"> abc=hello</span>
<span class="k">ENV</span><span class="s"> abc=bye def=$abc</span>
<span class="k">ENV</span><span class="s"> ghi=$abc</span>
</pre></div>
</div>
<p>この結果は、 <code class="docutils literal"><span class="pre">def</span></code> の値が <code class="docutils literal"><span class="pre">hello</span></code> であり、 <code class="docutils literal"><span class="pre">bye</span></code> ではありません。しかしながら <code class="docutils literal"><span class="pre">ghi</span></code> の値は <code class="docutils literal"><span class="pre">bye</span></code> になります。これは <code class="docutils literal"><span class="pre">abc</span></code> を <code class="docutils literal"><span class="pre">bye</span></code> に設定するのと同じコマンド行ではないためです。</p>
</div>
<div class="section" id="dockerignore">
<span id="dockerignore-file"></span><h2><a class="toc-backref" href="#id32">.dockerignore ファイル</a><a class="headerlink" href="#dockerignore" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>docker CLI がコンテクストを docker デーモンに送る前に、コンテクストのルートディレクトリ内の <code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルを探します。もしファイルが存在していれば、CLI はコンテクストからパターンに一致するファイルとディレクトリを除外します。これは不必要に大きくならないようにします。また、取り扱いに注意が必要なファイルやディレクトリをデーモンに送らないようにします。ですが、 <code class="docutils literal"><span class="pre">ADD</span></code> や <code class="docutils literal"><span class="pre">COPY</span></code> でイメージに追加されるかもしれません。</p>
<p>CLI は <code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルを行ごとに隔てて解釈します。行の一致パターンは Unix シェル上のものに似ています。パターンがコンテクストの root に一致すると考えられる場合は、root ディレクトリとして動作します。例えば、パターン <code class="docutils literal"><span class="pre">/foo/bar</span></code> と <code class="docutils literal"><span class="pre">foo/bar</span></code> がある場合、いずれも <code class="docutils literal"><span class="pre">PATH</span></code> における <code class="docutils literal"><span class="pre">foo</span></code> サブディレクトリの <code class="docutils literal"><span class="pre">bar</span></code> ファイルを削除します。あるいは <code class="docutils literal"><span class="pre">URL</span></code> の場所にある git のルートでもです。どちらでも除外されます。</p>
<p><code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルの１行目が <code class="docutils literal"><span class="pre">#</span></code> で始まる場合は、この合はコメントであると見なされ、CLI の処理からは無視されます。</p>
<p>これは <code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルの例です：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># コメント</span>
*/temp*
*/*/temp*
temp?
</pre></div>
</div>
<p>このファイルは構築時に以下の動作をします。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">#</span> <span class="pre">コメント</span></code> … 無視します。</li>
<li><code class="docutils literal"><span class="pre">*/temp*</span></code> … ルート以下のあらゆるサブディレクトリを含め、 <code class="docutils literal"><span class="pre">temp</span></code> で始まる名称のファイルとディレクトリを除外します。例えば、テキストファイル <code class="docutils literal"><span class="pre">/somedir/temporary.txt</span></code> は除外しますし、ディレクトリ <code class="docutils literal"><span class="pre">/somedir/temp</span></code> も除外します。</li>
<li><code class="docutils literal"><span class="pre">*/*/temp*</span></code> … ルートから２レベル以下の <code class="docutils literal"><span class="pre">temp</span></code> で 始まる名称のファイルとディレクトリを除外します。例えば <code class="docutils literal"><span class="pre">/somedir/subdir/temporary.txt</span></code> を除外します。</li>
<li><code class="docutils literal"><span class="pre">temp?</span></code> … ルートディレクトリにあるファイル名が <code class="docutils literal"><span class="pre">temp</span></code> と１文字一致するファイルとディレクトリを除外します。例えば、 <code class="docutils literal"><span class="pre">/tempa</span></code> と <code class="docutils literal"><span class="pre">/tempb</span></code> を除外します。</li>
</ul>
<p>一致には Go 言語の <a class="reference external" href="http://golang.org/pkg/path/filepath#Match">filepath.Match</a> ルールを使います。処理前のステップでは、空白スペースと <code class="docutils literal"><span class="pre">.</span></code> と <code class="docutils literal"><span class="pre">..</span></code> 要素を Go 言語の <a class="reference external" href="http://golang.org/pkg/path/filepath/#Clean">filepath.Clean</a> を用いて除外します。</p>
<p>行を <code class="docutils literal"><span class="pre">!</span></code> （エクスクラメーション・マーク）で始めると、除外ルールとして使えます。以下の例は <code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルでこの仕組みを使ったものです。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>*.md
!README.md
</pre></div>
</div>
<p><cite>README.md</cite> を除く全てのマークダウンファイルが、コンテントから除外されます。</p>
<p><code class="docutils literal"><span class="pre">!</span></code> 除外ルールが影響を与えるのは、 <code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルに書いた場所以降に一致するパターンが現れた時、含めるか除外するかを決めます。次の例で考えて見ましょう。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>*.md
!README*.md
README-secret.md
</pre></div>
</div>
<p>README を含むファイル以外は、<code class="docutils literal"><span class="pre">README-secret.md</span></code> も含め、残り全てのマークダウンファイルが除外対象です。</p>
<p>その次の例を考えましょう。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>*.md
README-secret.md
!README*.md
</pre></div>
</div>
<p>README を含む全てのファイル除外します。真ん中の行 <code class="docutils literal"><span class="pre">README-secret.md</span></code> は最終行の <code class="docutils literal"><span class="pre">!README*.md</span></code> に一致するため、何の影響もありません。</p>
<p><code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルは <code class="docutils literal"><span class="pre">Dockerfile</span></code> と <code class="docutils literal"><span class="pre">.dockerignore</span></code> ファイルの除外にも使えます。それでも、これらのファイルはジョブを処理するためデーモンに送信されます。しかし <code class="docutils literal"><span class="pre">ADD</span></code> と <code class="docutils literal"><span class="pre">COPY</span></code> コマンドは、これらをイメージ内にコピーしません。</p>
<p>最後に、特定のファイルのみコンテクストに含め、他を除外したい場合があるでしょう。実行するには、始めに <code class="docutils literal"><span class="pre">*</span></code> パターンに指定し、以下１つまたは複数の <code class="docutils literal"><span class="pre">!</span></code> 例外パターンを記述します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">歴史的な理由により、 <code class="docutils literal"><span class="pre">.</span></code> パターンは無視されます。</p>
</div>
</div>
<div class="section" id="from">
<span id="id5"></span><h2><a class="toc-backref" href="#id33">FROM</a><a class="headerlink" href="#from" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> &lt;イメージ&gt;</span>
</pre></div>
</div>
<p>または</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> &lt;イメージ&gt;:&lt;タグ&gt;</span>
</pre></div>
</div>
<p>または</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> &lt;イメージ&gt;@&lt;digest&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">FROM</span></code> 命令は、以降の命令で使う <a class="reference internal" href="../../glossary.html#base-image"><span class="std std-ref">ベース・イメージ</span></a> を指定します。あるいは、有効な <code class="docutils literal"><span class="pre">Dockerfile</span></code> は、１行めを <code class="docutils literal"><span class="pre">FROM</span></code> 命令で指定する必要があります。イメージとは、あらゆる有効なものが利用できます。 <span class="xref std std-doc">パブリック・リポジトリ</span> から <strong>イメージを取得する</strong> 方法が一番簡単です。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Dockerfile</span></code> では、コメント以外では <code class="docutils literal"><span class="pre">FROM</span></code> を一番始めに書く必要があります。</li>
</ul>
<ul class="simple">
<li>単一の <code class="docutils literal"><span class="pre">Dockerfile</span></code> から複数のイメージを作成するため、複数の <code class="docutils literal"><span class="pre">FROM</span></code> を指定できます。各 <code class="docutils literal"><span class="pre">FROM</span></code> 命令ごとに自動的にコミットし、最新のイメージ ID が出力されるのを覚えておいてください。</li>
</ul>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">タグ</span></code> や <code class="docutils literal"><span class="pre">digest</span></code> 値はオプションです。省略した場合、ビルダーはデフォルトの <code class="docutils literal"><span class="pre">latest</span></code> とみなします。ビルダーは一致する <code class="docutils literal"><span class="pre">tag</span></code> 値が無ければエラーを返します。</li>
</ul>
</div>
<div class="section" id="maintainer">
<span id="id6"></span><h2><a class="toc-backref" href="#id34">MAINTAINER</a><a class="headerlink" href="#maintainer" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">MAINTAINER</span><span class="s"> &lt;名前&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">MAINTAINER</span></code> 命令は、生成するイメージの <em>Author</em> （作者）フィールドを指定します。</p>
</div>
<div class="section" id="run">
<span id="id7"></span><h2><a class="toc-backref" href="#id35">RUN</a><a class="headerlink" href="#run" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>RUN には２つの形式があります。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">RUN</span> <span class="pre">&lt;コマンド&gt;</span></code> （シェル形式、コマンドを実行する。Linux 上のデフォルトは <code class="docutils literal"><span class="pre">/bin/sh</span> <span class="pre">-c</span></code> であり、Windows 上 <code class="docutils literal"><span class="pre">cmd</span> <span class="pre">/S</span> <span class="pre">/C</span></code> ）</li>
<li><code class="docutils literal"><span class="pre">RUN</span> <span class="pre">[&quot;実行バイナリ&quot;,</span> <span class="pre">&quot;パラメータ１&quot;,</span> <span class="pre">&quot;パラメータ２&quot;]</span></code> （ <em>exec</em> 形式）</li>
</ul>
<p><code class="docutils literal"><span class="pre">RUN</span></code> 命令は既存イメージ上の新しいレイヤで、あらゆるコマンドを実行し、その結果をコミットする命令です。コミットの結果得られたイメージは、 <code class="docutils literal"><span class="pre">Dockerfile</span></code> の次のステップで使われます。</p>
<p><code class="docutils literal"><span class="pre">RUN</span></code> 命令の積み重ねとコミットによるイメージ生成は、 Docker の中心となるコンセプト（概念）に従ったものです。コミットは簡単であり、ソース・コントロールのように、イメージの履歴上のあらゆる場所からコンテナを作成可能です。</p>
<p><em>exec</em> 形式はシェルの文字列を変更できないようにします。また、 指定されたシェル実行環境がベース・イメージに含まれなくても <code class="docutils literal"><span class="pre">RUN</span></code> コマンドを使えます。</p>
<p>デフォルトの <em>shell</em> のシェルを変更するには <code class="docutils literal"><span class="pre">SHELL</span></code> コマンドで変更できます。</p>
<p><em>シェル</em> 形式では、RUN 命令を <code class="docutils literal"><span class="pre">\</span></code> （バックスラッシュ）を使い、次の行と連結します。例えば、次の２行があるとします。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">RUN</span> /bin/bash -c <span class="s1">&#39;source $HOME/.bashrc ;\</span>
<span class="s1">echo $HOME&#39;</span>
</pre></div>
</div>
<p>これは、次のように１行にできます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">RUN</span> /bin/bash -c <span class="s1">&#39;source $HOME/.bashrc ; echo $HOME&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">「/bin/sh/」以外のシェルを使いたい場合は、exec 形式で任意のシェルを指定します。例： <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">[&quot;/bin/bash&quot;,</span> <span class="pre">&quot;-c&quot;,</span> <span class="pre">&quot;echo</span> <span class="pre">hello&quot;]</span></code> 。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">exec 形式は JSON 配列でパースされます。つまり、文字を囲むのはシングル・クォート(『) ではなくダブル・クォート(「)を使う必要があります。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><em>シェル</em> 形式と異なり、 <em>exec</em> 形式はコマンド・シェルを呼び出しません。つまり、通常のシェルによる処理が行われません。例えば <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">[</span> <span class="pre">&quot;echo&quot;,</span> <span class="pre">&quot;$HOME&quot;</span> <span class="pre">]</span></code> は <code class="docutils literal"><span class="pre">$HOME</span></code> の変数展開を行いません。シェルによる処理を行いたい場合は、 <em>シェル</em> 形式を使うか、あるいはシェルを直接指定します。例： <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">[</span> <span class="pre">&quot;sh&quot;,</span> <span class="pre">&quot;-c&quot;,</span> <span class="pre">&quot;echo&quot;,</span> <span class="pre">&quot;$HOME&quot;</span> <span class="pre">]</span></code> 。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">JSON 形式では、バック・スラッシュはエスケープが必要です。特に関係があるのは Windows でパス区切りにバック・スラッシュを使う場合です。次の行は JSON 形式ではなくシェル形式と見なされエラーになります： <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">[&quot;c:\windows\system32\tasklist.exe&quot;]</span></code> 。適切な構文は <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">[&quot;c:\\windows\\system32\\tasklist.exe&quot;]</span></code> です。</p>
</div>
<p>次の構築時、<code class="docutils literal"><span class="pre">RUN</span></code> 命令によるキャッシュは自動的に無効化できません。 <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">apt-get</span> <span class="pre">dist-upgrade</span> <span class="pre">-y</span></code> のような命令のキャッシュがあれば、次の構築時に再利用されます。 <code class="docutils literal"><span class="pre">RUN</span></code> 命令でキャッシュを使いたくない場合は、 <code class="docutils literal"><span class="pre">--no-cache</span></code> フラグを使います。例： <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span> <span class="pre">--no-cache</span></code> .</p>
<p>より詳しい情報は <code class="docutils literal"><span class="pre">Dockerfile</span></code> <a class="reference internal" href="../userguide/eng-image/dockerfile_best-practice.html#build-cache"><span class="std std-ref">ベスト・プラクティス・ガイド</span></a> をご覧ください。</p>
<p><code class="docutils literal"><span class="pre">RUN</span></code> 命令のキャッシュは、　<code class="docutils literal"><span class="pre">ADD</span></code> 命令によって無効化されます。詳細は <a class="reference internal" href="#add"><span class="std std-ref">以下</span></a> をご覧ください。</p>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id36">既知の問題(RUN)</a><a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/docker/docker/issues/783">Issue 783</a> は、AUFS ファイルシステム使用時、ファイルのパーミッションに関する問題が起こり得ます。例えば、ファイルを <code class="docutils literal"><span class="pre">rm</span></code> しようとする場合は注意が必要です。</li>
</ul>
<p>最近の aufs バージョンを使っているシステムでは（例： <code class="docutils literal"><span class="pre">dirperm1</span></code> マウント・オプションが利用可能 ）、docker は <code class="docutils literal"><span class="pre">dirperm1</span></code> オプションのレイヤをマウント時、自動的に問題を修正しようとします。 <code class="docutils literal"><span class="pre">dirperm1</span></code> オプションに関する詳細は、 <code class="docutils literal"><span class="pre">aufs</span></code> <a class="reference external" href="http://aufs.sourceforge.net/aufs3/man.html">man ページ</a> をご覧ください。</p>
<p>システムが <code class="docutils literal"><span class="pre">dirperm1</span></code> をサポートしていない場合は、issue に回避方法があります。</p>
</div>
</div>
<div class="section" id="cmd">
<span id="id9"></span><h2><a class="toc-backref" href="#id37">CMD</a><a class="headerlink" href="#cmd" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal"><span class="pre">CMD</span></code> には３つの形式があります。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">CMD</span> <span class="pre">[&quot;実行バイナリ&quot;,</span> <span class="pre">&quot;パラメータ１&quot;,</span> <span class="pre">&quot;パラメータ２&quot;]</span></code> （ <em>exec</em> 形式、推奨する形式）</li>
<li><code class="docutils literal"><span class="pre">CMD</span> <span class="pre">[&quot;パラメータ１&quot;,</span> <span class="pre">&quot;パラメータ２&quot;]</span></code> （ <em>ENTRYPOINT</em> のデフォルト・パラメータ）</li>
<li><code class="docutils literal"><span class="pre">CMD</span> <span class="pre">&lt;コマンド&gt;</span></code> （シェル形式）</li>
</ul>
<p><code class="docutils literal"><span class="pre">Dockerfile</span></code> で <code class="docutils literal"><span class="pre">CMD</span></code> 命令を一度だけ指定できます。複数の <code class="docutils literal"><span class="pre">CMD</span></code> がある場合、最も後ろの <code class="docutils literal"><span class="pre">CMD</span></code> のみ有効です。</p>
<p><code class="docutils literal"><span class="pre">CMD</span></code> の主な目的は、 <strong>コンテナ実行時のデフォルトを提供します</strong> 。 デフォルトには、実行可能なコマンドが含まれているか、あるいは省略されるかもしれません。省略時は <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 命令で同様に指定する必要があります。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 命令のデフォルトの引数として <code class="docutils literal"><span class="pre">CMD</span></code> を使う場合、 <code class="docutils literal"><span class="pre">CMD</span></code> と <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 命令の両方が JSON 配列フォーマットになっている必要があります。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><em>exec</em> 形式は JSON 配列でパースされます。つまり、文字を囲むのはシングル・クォート(『) ではなくダブル・クォート(「)を使う必要があります。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><em>シェル</em> 形式と異なり、 <em>exec</em> 形式はコマンド・シェルを呼び出しません。つまり、通常のシェルによる処理が行われません。例えば <code class="docutils literal"><span class="pre">CMD</span> <span class="pre">[</span> <span class="pre">&quot;echo&quot;,</span> <span class="pre">&quot;$HOME&quot;</span> <span class="pre">]</span></code> は <code class="docutils literal"><span class="pre">$HOME</span></code> の変数展開を行いません。シェルによる処理を行いたい場合は、 <em>シェル</em> 形式を使うか、あるいはシェルを直接使います。例： <code class="docutils literal"><span class="pre">CMD</span> <span class="pre">[</span> <span class="pre">&quot;sh&quot;,</span> <span class="pre">&quot;-c&quot;,</span> <span class="pre">&quot;echo&quot;,</span> <span class="pre">&quot;$HOME&quot;</span> <span class="pre">]</span></code> 。</p>
</div>
<p>シェルあるいは exec 形式を使う時、 <code class="docutils literal"><span class="pre">CMD</span></code> 命令はイメージで実行するコマンドを指定します。</p>
<p><code class="docutils literal"><span class="pre">CMD</span></code> を <em>シェル</em> 形式で使えば、 <code class="docutils literal"><span class="pre">&lt;コマンド&gt;</span></code> は <code class="docutils literal"><span class="pre">/bin/sh</span> <span class="pre">-c</span></code> で実行されます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">CMD</span><span class="s"> echo &quot;This is a test.&quot; | wc -</span>
</pre></div>
</div>
<p><strong>&lt;コマンド&gt;をシェルを使わずに実行</strong> したい場合、コマンドを JSON 配列で記述し、実行可能なフルパスで指定する必要があります。 <strong>配列の形式が CMD では望ましい形式です</strong> 。あらゆる追加パラメータは個々の配列の文字列として指定する必要があります。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">CMD</span><span class="s"> [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</span>
</pre></div>
</div>
<p>もしコンテナで毎回同じものを実行するのであれば、 <code class="docutils literal"><span class="pre">CMD</span></code> と <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> の使用を検討ください。詳細は <a class="reference internal" href="../../glossary.html#entrypoint"><span class="std std-ref">ENTRYPOINT</span></a> をご覧ください。</p>
<p>ユーザが <code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span></code> で引数を指定した時、これらは <code class="docutils literal"><span class="pre">CMD</span></code> で指定したデフォルトを上書きします。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">RUN</span></code> と <code class="docutils literal"><span class="pre">CMD</span></code> を混同しないでください。 <code class="docutils literal"><span class="pre">RUN</span></code> が実際に行っているのは、コマンドの実行と結果のコミットです。一方の <code class="docutils literal"><span class="pre">CMD</span></code> は構築時には何もしませんが、イメージで実行するコマンドを指定します。</p>
</div>
</div>
<div class="section" id="label">
<span id="id10"></span><h2><a class="toc-backref" href="#id38">LABEL</a><a class="headerlink" href="#label" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>LABEL &lt;key&gt;<span class="o">=</span>&lt;value&gt; &lt;key&gt;<span class="o">=</span>&lt;value&gt; &lt;key&gt;<span class="o">=</span>&lt;value&gt; ...
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">LABEL</span></code> 命令はイメージにメタデータを追加します。 <code class="docutils literal"><span class="pre">LABEL</span></code> はキーとバリューのペアです。 <code class="docutils literal"><span class="pre">LABEL</span></code> の値に空白スペースを含む場合はクォートを使いますし、コマンドラインの分割にバックスラッシュを使います。使用例：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>LABEL <span class="s2">&quot;com.example.vendor&quot;</span><span class="o">=</span><span class="s2">&quot;ACME Incorporated&quot;</span>
LABEL com.example.label-with-value<span class="o">=</span><span class="s2">&quot;foo&quot;</span>
LABEL <span class="nv">version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span>
LABEL <span class="nv">description</span><span class="o">=</span><span class="s2">&quot;This text illustrates \</span>
<span class="s2">that label-values can span multiple lines.&quot;</span>
</pre></div>
</div>
<p>イメージは複数のラベルを持てます。複数のラベルを指定したら、 Docker は可能であれば１つの <code class="docutils literal"><span class="pre">LABEL</span></code> にすることをお勧めします。各 <code class="docutils literal"><span class="pre">LABEL</span></code> 命令は新しいレイヤを準備しますが、多くのラベルを使えば、それだけレイヤを使います。次の例は１つのイメージ・レイヤを使うものです。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>LABEL multi.label1<span class="o">=</span><span class="s2">&quot;value1&quot;</span> multi.label2<span class="o">=</span><span class="s2">&quot;value2&quot;</span> <span class="nv">other</span><span class="o">=</span><span class="s2">&quot;value3&quot;</span>
</pre></div>
</div>
<p>上記の例は、次のようにも書き換えられます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>LABEL multi.label1<span class="o">=</span><span class="s2">&quot;value1&quot;</span> <span class="se">\</span>
      multi.label2<span class="o">=</span><span class="s2">&quot;value2&quot;</span> <span class="se">\</span>
      <span class="nv">other</span><span class="o">=</span><span class="s2">&quot;value3&quot;</span>
</pre></div>
</div>
<p>ラベルには、<code class="docutils literal"><span class="pre">FROM</span></code> イメージが使う <code class="docutils literal"><span class="pre">LABEL</span></code> も含まれています。ラベルのキーが既に存在している時、Docker は特定のキーを持つラベルの値を上書きします。</p>
<p>イメージが使っているラベルを確認するには、 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">inspect</span></code> コマンドを使います。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="s2">&quot;Labels&quot;</span>: <span class="o">{</span>
    <span class="s2">&quot;com.example.vendor&quot;</span>: <span class="s2">&quot;ACME Incorporated&quot;</span>
    <span class="s2">&quot;com.example.label-with-value&quot;</span>: <span class="s2">&quot;foo&quot;</span>,
    <span class="s2">&quot;version&quot;</span>: <span class="s2">&quot;1.0&quot;</span>,
    <span class="s2">&quot;description&quot;</span>: <span class="s2">&quot;This text illustrates that label-values can span multiple lines.&quot;</span>,
    <span class="s2">&quot;multi.label1&quot;</span>: <span class="s2">&quot;value1&quot;</span>,
    <span class="s2">&quot;multi.label2&quot;</span>: <span class="s2">&quot;value2&quot;</span>,
    <span class="s2">&quot;other&quot;</span>: <span class="s2">&quot;value3&quot;</span>
<span class="o">}</span>,
</pre></div>
</div>
</div>
<div class="section" id="expose">
<span id="id11"></span><h2><a class="toc-backref" href="#id39">EXPOSE</a><a class="headerlink" href="#expose" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">EXPOSE</span><span class="s"> &lt;port&gt; [&lt;port&gt;...]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">EXPOSE</span></code> 命令は、特定のネットワーク・ポートをコンテナが実行時にリッスンすることを Docker に伝えます。 <code class="docutils literal"><span class="pre">EXPOSE</span></code> があっても、これだけではホストからコンテナにアクセスできるようにしません。アクセスするには、 <code class="docutils literal"><span class="pre">-p</span></code> フラグを使ってポートの公開範囲を指定するか、 <code class="docutils literal"><span class="pre">-P</span></code> フラグで全ての露出ポートを公開する必要があります。外部への公開時は他のポート番号も利用可能です。</p>
<p>ホストシステム上でポート転送を使うには、 <a class="reference internal" href="run.html#expose-incoming-ports"><span class="std std-ref">-P フラグを使う</span></a> をご覧ください。Docker のネットワーク機能は、ネットワーク内でポートを公開しないネットワークを作成可能です。詳細な情報は <a class="reference internal" href="../userguide/networking/index.html"><span class="doc">機能概要</span></a> をご覧ください。</p>
</div>
<div class="section" id="env">
<span id="id12"></span><h2><a class="toc-backref" href="#id40">ENV</a><a class="headerlink" href="#env" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">ENV</span><span class="s"> &lt;key&gt; &lt;value&gt;</span>
<span class="k">ENV</span><span class="s"> &lt;key&gt;=&lt;value&gt; ...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ENV</span></code> 命令は、環境変数 <code class="docutils literal"><span class="pre">&lt;key&gt;</span></code> と 値 <code class="docutils literal"><span class="pre">&lt;value&gt;</span></code> のセットです。値は <code class="docutils literal"><span class="pre">Dockerfile</span></code> から派生する全てのコマンド環境で利用でき、 <a class="reference internal" href="#environment-replacement"><span class="std std-ref">インラインで置き換え</span></a> も可能です。</p>
<p><code class="docutils literal"><span class="pre">ENV</span></code> 命令は２つの形式があります。１つめは、 <code class="docutils literal"><span class="pre">ENV</span> <span class="pre">&lt;key&gt;</span> <span class="pre">&lt;value&gt;</span></code> であり、変数に対して１つの値を設定します。はじめの空白以降の文字列が <code class="docutils literal"><span class="pre">&lt;value&gt;</span></code> に含まれます。ここには空白もクォートも含まれます。</p>
<p>２つめの形式は <code class="docutils literal"><span class="pre">ENV</span> <span class="pre">&lt;key&gt;=&lt;value&gt;</span> <span class="pre">...</span></code> です。これは一度に複数の変数を指定できます。先ほどと違い、構文の２つめにイコールサイン（=）があるので気を付けてください。コマンドラインの分割、クォート、バックスラッシュは、空白スペースも含めて値になります。</p>
<p>例：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">ENV</span><span class="s"> myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \</span>
    <span class="nv">myCat</span><span class="o">=</span>fluffy
</pre></div>
</div>
<p>そして</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">ENV</span><span class="s"> myName John Doe</span>
<span class="k">ENV</span><span class="s"> myDog Rex The Dog</span>
<span class="k">ENV</span><span class="s"> myCat fluffy</span>
</pre></div>
</div>
<p>この例では、どちらも最終的に同じ結果をコンテナにもたらしますが、私たちが推奨するのは前者です。理由は前者であれば単一のキャッシュ・レイヤしか使わないからです。</p>
<p>環境変数の設定に <code class="docutils literal"><span class="pre">ENV</span></code> を使えば、作成したイメージを使ってコンテナを実行しても有効です。どのような値が設定されているかは <code class="docutils literal"><span class="pre">docker</span> <span class="pre">inspect</span></code> で確認でき、変更するには <code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">--env</span> <span class="pre">&lt;key&gt;=&lt;value&gt;</span></code> を使います。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">環境変数の一貫性は予期しない影響を与える場合があります。例えば、 <code class="docutils literal"><span class="pre">ENV</span> <span class="pre">DEBIAN_FRONTEND</span> <span class="pre">noninteractive</span></code> が設定されていると、Debian ベースのイメージで apt-get の利用者が混乱するかもしれません。１つのコマンドだけで値を設定するには、 <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">&lt;key&gt;=&lt;value&gt;</span> <span class="pre">&lt;コマンド&gt;</span></code> を使います。</p>
</div>
</div>
<div class="section" id="add">
<span id="id13"></span><h2><a class="toc-backref" href="#id41">ADD</a><a class="headerlink" href="#add" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Add は２つの形式があります。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ADD</span> <span class="pre">&lt;ソース&gt;...</span> <span class="pre">&lt;送信先&gt;</span></code></li>
<li><code class="docutils literal"><span class="pre">ADD</span> <span class="pre">[&quot;&lt;ソース&gt;&quot;,</span> <span class="pre">...</span> <span class="pre">&quot;&lt;送信先&gt;&quot;]</span></code> （この形式はパスに空白スペースを使う場合に必要）</li>
</ul>
<p><code class="docutils literal"><span class="pre">ADD</span></code> 命令は <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> にある新しいファイルやディレクトリをコピー、あるいはリモートの URL からコピーします。それから、コンテナ内のファイルシステム上にある <code class="docutils literal"><span class="pre">送信先</span></code> に指定されたパスに追加します。</p>
<p>複数の <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> リソースを指定できます。この時、ファイルやディレクトリはソースディレクトリ（構築時のコンテクスト）からの相対パス上に存在しないと構築できません。</p>
<p>それぞれの <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> にはワイルドカードと Go 言語の <a class="reference external" href="http://golang.org/pkg/path/filepath#Match">filepath.Match</a> ルールに一致するパターンが使えます。例えば、次のような記述です。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">ADD</span><span class="s"> hom* /mydir/        # &quot;hom&quot; で始まる全てのファイルを追加</span>
<span class="k">ADD</span><span class="s"> hom?.txt /mydir/    # ? は１文字だけ一致します。例： &quot;home.txt&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> は絶対パスです。あるいは、パスは <code class="docutils literal"><span class="pre">WORKDIR</span></code> からの相対パスです。ソースにあるものが、対象となる送信先コンテナの中にコピーされます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">ADD</span><span class="s"> test relativeDir/          # &quot;test&quot; を `WORKDIR`/relativeDir/ （相対ディレクトリ）に追加</span>
<span class="k">ADD</span><span class="s"> test /absoluteDir/          # &quot;test&quot; を /absoluteDir/ （絶対ディレクトリ）に追加</span>
</pre></div>
</div>
<p>追加される新しいファイルやディレクトリは、全て UID と GID が 0 として作成されます。</p>
<p><code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> がリモート URL の場合は、送信先のパーミッションは 600 にします。もしリモートのファイルが HTTP <code class="docutils literal"><span class="pre">Last-Modified</span></code> ヘッダを返す場合は、このヘッダの情報を元に送信先ファイルの <code class="docutils literal"><span class="pre">mtime</span></code> を指定するのに使います。しかしながら、 <code class="docutils literal"><span class="pre">ADD</span></code> を使ったファイルをコピーする手順では、 <code class="docutils literal"><span class="pre">mtime</span></code> はファイルが更新されたかどうかの決定には使われず、ファイルが更新されればキャッシュも更新されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">Dockerfile</span></code> を標準入力（ <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-</span> <span class="pre">&lt;</span> <span class="pre">何らかのファイル</span></code> ）を通して構築しようとしても。構築時のコンテントは存在しないため、 <code class="docutils literal"><span class="pre">Dockerfile</span></code> には URL を指定する <code class="docutils literal"><span class="pre">ADD</span></code> 命令のみ記述可能です。また、圧縮ファイルを標準入力（ <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-</span> <span class="pre">&lt;</span> <span class="pre">archive.tar.gz</span></code> ）を通すことができ、アーカイブに含まれるルートに <code class="docutils literal"><span class="pre">Dockerfile</span></code> があれば、構築時のコンテクストとしてアーカイブが使われます。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">URL で指定したファイルに認証がかかっている場合は、 <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">wget</span></code> や <code class="docutils literal"><span class="pre">RUN</span> <span class="pre">curl</span></code> や他のツールを使う必要があります。これは <code class="docutils literal"><span class="pre">ADD</span></code> 命令が認証機能をサポートしていないからです。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">ADD</span></code> 命令の処理時、まず <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> に含まれる内容が変更されていれば、以降の <code class="docutils literal"><span class="pre">Dockerfile</span></code> に書かれている命令のキャッシュを全て無効化します。これは <code class="docutils literal"><span class="pre">RUN</span></code> 命令のキャッシュ無効化も含まれます。より詳細な情報については <code class="docutils literal"><span class="pre">Dockerfile</span></code> の <a class="reference internal" href="../userguide/eng-image/dockerfile_best-practice.html#build-cache"><span class="std std-ref">ベスト・プラクティス・ガイド</span></a> をご覧ください。</p>
</div>
<p><code class="docutils literal"><span class="pre">ADD</span></code> は以下のルールに従います。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> パスは、構築時の <em>コンテント</em> 内にある必要があります。そのため、 <code class="docutils literal"><span class="pre">ADD</span> <span class="pre">../something</span> <span class="pre">/something</span></code> の指定はできません。 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span></code> の最初のステップで、コンテクストのディレクトリ（と、サブディレクトリ）を docker デーモンに送るためです。</li>
</ul>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> が URL であり、 <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> の末尾にスラッシュが無い場合、URL からファイルをダウンロードし、 <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> にコピーします。</li>
</ul>
<ul class="simple">
<li>もし <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> が URL であり、 <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> の末尾がスラッシュの場合、URL からファイル名を推測し、ファイルを <code class="docutils literal"><span class="pre">&lt;送信先&gt;/&lt;ファイル名&gt;</span></code> にダウンロードします。例えば、 <code class="docutils literal"><span class="pre">ADD</span> <span class="pre">http://example.com/foobar</span> <span class="pre">/</span></code> は、 <code class="docutils literal"><span class="pre">/foobar</span></code> ファイルを作成します。URL には何らかのパスが必要です。これは適切なファイル名を見つけられない場合があるためです（今回の例では、 <code class="docutils literal"><span class="pre">http://example.com</span></code> の指定は動作しません）。</li>
</ul>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> がディレクトリの場合、ディレクトリの内容の全てをコピーします。これにはファイルシステムのメタデータを含みます。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ディレクトリ自身はコピーされません。ディレクトリは単なるコンテントの入れ物です。</p>
</div>
<ul class="simple">
<li>もし <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> が <em>ローカル</em> にある tar アーカイブの場合、圧縮フォーマットを認識します（gzip、bzip2、xz を認識）。それからディレクトリに展開します。 <em>リモート</em> の URL が指定された場合は展開 <strong>しません</strong>。ディレクトリにコピーまたは展開する時は、 <code class="docutils literal"><span class="pre">tar</span> <span class="pre">-x</span></code> と同じ働きをします。結果は次の処理を同時に行います。</li>
</ul>
<ol class="arabic simple">
<li>送信先のパスが存在しているかどうか</li>
<li>ファイル単位の原則に従って、ソース・ツリーの内容と衝突しないかどうか「2」を繰り返す</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ファイルが圧縮フォーマットと認識するか、あるいはファイルの集まりをベースにしているのかは、ファイルの名前では判断しません。例えば、空のファイル名の拡張子が <code class="docutils literal"><span class="pre">.tar.gz</span></code> だとしても、圧縮ファイルと認識しないため、展開エラーのメッセージを表示 <strong>しません</strong> 。そして単純に送信先にファイルをコピーします。</p>
</div>
<ul class="simple">
<li>もし <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> がファイル以外であれば、個々のメタデータと一緒にコピーします。 <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> の末尾がスラッシュ <code class="docutils literal"><span class="pre">/</span></code> で終わる場合は、ディレクトリであるとみなし、 <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> の内容を <code class="docutils literal"><span class="pre">&lt;送信先&gt;/base(&lt;ソース&gt;)</span></code> に書き込みます。</li>
</ul>
<ul class="simple">
<li>もし複数の <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> リソースが指定された場合や、ディレクトリやワイルドカードを使った場合、 <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> は必ずディレクトリになり、最後はスラッシュ <code class="docutils literal"><span class="pre">/</span></code> にしなければいけません。</li>
</ul>
<ul class="simple">
<li>もし <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> の末尾がスラッシュで終わらなければ、通常のファイルとみなされ、 <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> の内容は <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> として書き込まれます。</li>
</ul>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> が存在しなければ、パスに存在しないディレクトリを作成します。</li>
</ul>
</div>
<div class="section" id="copy">
<span id="id15"></span><h2><a class="toc-backref" href="#id42">COPY</a><a class="headerlink" href="#copy" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>COPY は２つの形式があります。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">COPY</span> <span class="pre">&lt;ソース&gt;...</span> <span class="pre">&lt;送信先&gt;</span></code></li>
<li><code class="docutils literal"><span class="pre">COPY</span> <span class="pre">[&quot;&lt;ソース&gt;&quot;,...</span> <span class="pre">&quot;&lt;送信先&gt;&quot;]</span></code> （この形式はパスに空白スペースを使う場合に必要）</li>
</ul>
<p><code class="docutils literal"><span class="pre">COPY</span></code> 命令は <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> にある新しいファイルやディレクトリをコピーするもので、コンテナ内のファイルシステム上にある <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> に指定されたパスに追加します。</p>
<p>複数の <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> リソースを指定できます。この時、ソースディレクトリ（構築時のコンテクスト）からの相対パス上に存在しないと構築できません。</p>
<p>それぞれの <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> にはワイルドカードと Go 言語の <a class="reference external" href="http://golang.org/pkg/path/filepath#Match">filepath.Match</a> ルールに一致するパターンが使えます。例えば、次のような記述です。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>COPY hom* /mydir/        # <span class="s2">&quot;hom&quot;</span> で始まる全てのファイルを追加
COPY hom?.txt /mydir/    # ? は１文字だけ一致します。例： <span class="s2">&quot;home.txt&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> は絶対パスです。あるいは、パスは <code class="docutils literal"><span class="pre">WORKDIR</span></code> からの相対パスです。ソースにあるものが、対象となる送信先コンテナの中にコピーされます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>COPY <span class="nb">test</span> relativeDir/   # <span class="s2">&quot;test&quot;</span> を <span class="sb">`</span>WORKDIR<span class="sb">`</span>/relativeDir/ （相対ディレクトリ）に追加
COPY <span class="nb">test</span> /absoluteDir/   # <span class="s2">&quot;test&quot;</span> を /absoluteDir/ （絶対ディレクトリ）に追加
</pre></div>
</div>
<p>追加される新しいファイルやディレクトリは、全て UID と GID が 0 として作成されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">標準入力（ <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-</span> <span class="pre">&lt;</span> <span class="pre">何らかのファイル</span></code> ）を使って構築しようとしても、構築時のコンテントは存在しないため、 <code class="docutils literal"><span class="pre">COPY</span></code> を使えません。</p>
</div>
<p><code class="docutils literal"><span class="pre">COPY</span></code> は以下のルールに従います。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> パスは、構築時の <em>コンテント</em> 内にある必要があります。そのため、 <code class="docutils literal"><span class="pre">COPY</span> <span class="pre">../something</span> <span class="pre">/something</span></code> の指定はできません。 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span></code> の最初のステップで、コンテクストのディレクトリ（と、サブディレクトリ）を docker デーモンに送るためです。</li>
</ul>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> がディレクトリの場合、ディレクトリ内容の全てをコピーします。これにはファイルシステムのメタデータを含みます。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ディレクトリ自身はコピーしません。ディレクトリは単なるコンテントの入れ物です。</p>
</div>
<ul class="simple">
<li>もし <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> がファイル以外であれば、個々のメタデータと一緒にコピーします。 <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> の末尾がスラッシュ <code class="docutils literal"><span class="pre">/</span></code> で終わる場合は、ディレクトリであるとみなし、 <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> の内容を <code class="docutils literal"><span class="pre">&lt;送信先&gt;/base(&lt;ソース&gt;)</span></code> に書き込みます。</li>
</ul>
<ul class="simple">
<li>もし複数の <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> リソースが指定された場合や、ディレクトリやワイルドカードを使った場合、 <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> は必ずディレクトリになり、最後はスラッシュ <code class="docutils literal"><span class="pre">/</span></code> にしなければいけません。</li>
</ul>
<ul class="simple">
<li>もし <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> の末尾がスラッシュで終わらなければ、通常のファイルとみなされ、 <code class="docutils literal"><span class="pre">&lt;ソース&gt;</span></code> の内容は <code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> として書き込まれます。</li>
</ul>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;送信先&gt;</span></code> が存在しなければ、パスに存在しないディレクトリを作成します。</li>
</ul>
</div>
<div class="section" id="entrypoint">
<span id="id17"></span><h2><a class="toc-backref" href="#id43">ENTRYPOINT</a><a class="headerlink" href="#entrypoint" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ENTRYPOINT には２つの形式があります。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ENTRYPOINT</span> <span class="pre">[&quot;実行可能なもの&quot;,</span> <span class="pre">&quot;パラメータ１&quot;,</span> <span class="pre">&quot;パラメータ２&quot;]</span></code> （ <em>exec</em> 形式、推奨）</li>
<li><code class="docutils literal"><span class="pre">ENTRYPOINT</span> <span class="pre">コマンド</span> <span class="pre">パラメータ１</span> <span class="pre">パラメータ２</span></code> （ <em>シェル</em> 形式）</li>
</ul>
<p><code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> はコンテナが実行するファイルを設定します。</p>
<p>例えば、次の例は nginx をデフォルトの内容で開始し、ポート 80 を開きます。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>docker run -i -t --rm -p <span class="m">80</span>:80 nginx
</pre></div>
</div>
<p>コマンドラインで <code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">&lt;イメージ&gt;</span></code> コマンドに引数を付けますと、<em>exec</em> 形式 の <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> で指定した全要素の後に追加します。そして、この時に <code class="docutils literal"><span class="pre">CMD</span></code> を使って指定していた要素を上書きします。この動きにより、引数はエントリ・ポイント（訳者注：指定されたバイナリ）に渡されます。例えば、 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">&lt;イメージ&gt;</span> <span class="pre">-d</span></code> は、引数 <code class="docutils literal"><span class="pre">-d</span></code> をエントリポイントに渡します。 <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 命令を上書きするには、 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">--entrypoint</span></code> フラグを使います。</p>
<p><em>シェル</em> 形式では <code class="docutils literal"><span class="pre">CMD</span></code> や <code class="docutils literal"><span class="pre">run</span></code> コマンド行の引数を使えないという不利な点があります。 <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> は <code class="docutils literal"><span class="pre">/bin/sh</span> <span class="pre">-c</span></code> のサブコマンドとして実行されるため、シグナルを渡せません。つまり、何かを実行してもコンテナの <code class="docutils literal"><span class="pre">PID</span> <span class="pre">1</span></code> にはなりません。そして、 Unix シグナルを受け付け <em>ません</em>。そのため、実行ファイルは <code class="docutils literal"><span class="pre">docker</span> <span class="pre">stop</span> <span class="pre">&lt;コンテナ&gt;</span></code> を実行しても、 <code class="docutils literal"><span class="pre">SIGTERM</span></code>  を受信しません。</p>
<p>なお、 <code class="docutils literal"><span class="pre">Dockerfile</span></code> の最後に現れた <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 命令のみ有効です。</p>
<div class="section" id="exec-entrypoint">
<h3><a class="toc-backref" href="#id44">exec 形式の ENTRYPOINT 例</a><a class="headerlink" href="#exec-entrypoint" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> の <em>exec</em> 形式を使い、適切なデフォルトのコマンドと引数を指定します。それから <code class="docutils literal"><span class="pre">CMD</span></code> を使い、変更する可能性のある追加のデフォルト引数も指定します。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">ENTRYPOINT</span><span class="s"> [&quot;top&quot;, &quot;-b&quot;]</span>
<span class="k">CMD</span><span class="s"> [&quot;-c&quot;]</span>
</pre></div>
</div>
<p>コンテナを実行したら、 <code class="docutils literal"><span class="pre">top</span></code> のプロセスが１つだけ見えます。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker run -it --rm --name <span class="nb">test</span>  top -H
top - <span class="m">08</span>:25:00 up  <span class="m">7</span>:27,  <span class="m">0</span> users,  load average: <span class="m">0</span>.00, <span class="m">0</span>.01, <span class="m">0</span>.05
Threads:   <span class="m">1</span> total,   <span class="m">1</span> running,   <span class="m">0</span> sleeping,   <span class="m">0</span> stopped,   <span class="m">0</span> zombie
%Cpu<span class="o">(</span>s<span class="o">)</span>:  <span class="m">0</span>.1 us,  <span class="m">0</span>.1 sy,  <span class="m">0</span>.0 ni, <span class="m">99</span>.7 id,  <span class="m">0</span>.0 wa,  <span class="m">0</span>.0 hi,  <span class="m">0</span>.0 si,  <span class="m">0</span>.0 st
KiB Mem:   <span class="m">2056668</span> total,  <span class="m">1616832</span> used,   <span class="m">439836</span> free,    <span class="m">99352</span> buffers
KiB Swap:  <span class="m">1441840</span> total,        <span class="m">0</span> used,  <span class="m">1441840</span> free.  <span class="m">1324440</span> cached Mem

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
    <span class="m">1</span> root      <span class="m">20</span>   <span class="m">0</span>   <span class="m">19744</span>   <span class="m">2336</span>   <span class="m">2080</span> R  <span class="m">0</span>.0  <span class="m">0</span>.1   <span class="m">0</span>:00.04 top
</pre></div>
</div>
<p>より詳細なテストをするには、 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">exec</span></code> コマンドが使えます。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it <span class="nb">test</span> ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="m">1</span>  <span class="m">2</span>.6  <span class="m">0</span>.1  <span class="m">19752</span>  <span class="m">2352</span> ?        Ss+  <span class="m">08</span>:24   <span class="m">0</span>:00 top -b -H
root         <span class="m">7</span>  <span class="m">0</span>.0  <span class="m">0</span>.1  <span class="m">15572</span>  <span class="m">2164</span> ?        R+   <span class="m">08</span>:25   <span class="m">0</span>:00 ps aux
</pre></div>
</div>
<p>それから、<code class="docutils literal"><span class="pre">docker</span> <span class="pre">stop</span> <span class="pre">test</span></code> を使い <code class="docutils literal"><span class="pre">top</span></code> を停止するよう、通常のリクエストを行えます。</p>
<p>次の <code class="docutils literal"><span class="pre">Dockerfile</span></code> は <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> を使って Apache をフォアグラウンドで実行します（つまり、 <code class="docutils literal"><span class="pre">PID</span> <span class="pre">1</span></code> として）。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> debian:stable</span>
<span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> apt-get install -y --force-yes apache2
<span class="k">EXPOSE</span><span class="s"> 80 443</span>
<span class="k">VOLUME</span><span class="s"> [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]</span>
<span class="k">ENTRYPOINT</span><span class="s"> [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span>
</pre></div>
</div>
<p>もし実行するだけの起動スクリプトを書く必要があれば、最後に実行するコマンドが Unix シグナルを受信できるよう、 <code class="docutils literal"><span class="pre">exec</span></code> と <code class="docutils literal"><span class="pre">gosu</span></code> コマンドを使うことで可能になります。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="nb">set</span> -e

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s1">&#39;postgres&#39;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    chown -R postgres <span class="s2">&quot;</span><span class="nv">$PGDATA</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;</span><span class="k">$(</span>ls -A <span class="s2">&quot;</span><span class="nv">$PGDATA</span><span class="s2">&quot;</span><span class="k">)</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        gosu postgres initdb
    <span class="k">fi</span>

    <span class="nb">exec</span> gosu postgres <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="nb">exec</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>もしも、シャットダウン時に何らかの追加クリーンアップ（あるいは、他のコンテナとの通信）が必要な場合や、１つ以上の実行ファイルと連携したい場合は、 <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> のスクリプトが Unix シグナルを受信出来るようにし、それを使って様々な処理を行います。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="c1"># メモ：これは sh を使っていますので、busyboy コンテナでも動きます</span>

<span class="c1"># サービス停止時に手動でもクリーンアップが必要な場合は trap を使います。</span>
<span class="c1"># あるいは１つのコンテナ内に複数のサービスを起動する必要があります。</span>
<span class="nb">trap</span> <span class="s2">&quot;echo TRAPed signal&quot;</span> HUP INT QUIT TERM

<span class="c1"># ここからバックグラウンドでサービスを開始します</span>
/usr/sbin/apachectl start

<span class="nb">echo</span> <span class="s2">&quot;[hit enter key to exit] or run &#39;docker stop &lt;container&gt;&#39;&quot;</span>
<span class="nb">read</span>

<span class="c1"># ここからサービスを停止し、クリーンアップします</span>
<span class="nb">echo</span> <span class="s2">&quot;stopping apache&quot;</span>
/usr/sbin/apachectl stop

<span class="nb">echo</span> <span class="s2">&quot;exited </span><span class="nv">$0</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>このイメージを <code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">-it</span> <span class="pre">--rm</span> <span class="pre">-p</span> <span class="pre">80:80</span> <span class="pre">--name</span> <span class="pre">test</span> <span class="pre">apache</span></code> で実行したら、コンテナのプロセス状態を <code class="docutils literal"><span class="pre">docker</span> <span class="pre">exec</span></code> や <code class="docutils literal"><span class="pre">docker</span> <span class="pre">top</span></code> で調べられます。それから、スクリプトに Apache 停止を依頼します。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it <span class="nb">test</span> ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="m">1</span>  <span class="m">0</span>.1  <span class="m">0</span>.0   <span class="m">4448</span>   <span class="m">692</span> ?        Ss+  <span class="m">00</span>:42   <span class="m">0</span>:00 /bin/sh /run.sh <span class="m">123</span> cmd cmd2
root        <span class="m">19</span>  <span class="m">0</span>.0  <span class="m">0</span>.2  <span class="m">71304</span>  <span class="m">4440</span> ?        Ss   <span class="m">00</span>:42   <span class="m">0</span>:00 /usr/sbin/apache2 -k start
www-data    <span class="m">20</span>  <span class="m">0</span>.2  <span class="m">0</span>.2 <span class="m">360468</span>  <span class="m">6004</span> ?        Sl   <span class="m">00</span>:42   <span class="m">0</span>:00 /usr/sbin/apache2 -k start
www-data    <span class="m">21</span>  <span class="m">0</span>.2  <span class="m">0</span>.2 <span class="m">360468</span>  <span class="m">6000</span> ?        Sl   <span class="m">00</span>:42   <span class="m">0</span>:00 /usr/sbin/apache2 -k start
root        <span class="m">81</span>  <span class="m">0</span>.0  <span class="m">0</span>.1  <span class="m">15572</span>  <span class="m">2140</span> ?        R+   <span class="m">00</span>:44   <span class="m">0</span>:00 ps aux
$ docker top <span class="nb">test</span>
PID                 USER                COMMAND
<span class="m">10035</span>               root                <span class="o">{</span>run.sh<span class="o">}</span> /bin/sh /run.sh <span class="m">123</span> cmd cmd2
<span class="m">10054</span>               root                /usr/sbin/apache2 -k start
<span class="m">10055</span>               <span class="m">33</span>                  /usr/sbin/apache2 -k start
<span class="m">10056</span>               <span class="m">33</span>                  /usr/sbin/apache2 -k start
$ /usr/bin/time docker stop <span class="nb">test</span>
<span class="nb">test</span>
real 0m <span class="m">0</span>.27s
user 0m <span class="m">0</span>.03s
sys  0m <span class="m">0</span>.03s
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">ENTRYPIONT</span></code> 設定は <code class="docutils literal"><span class="pre">--entrypoint</span></code>  を使って上書きできますが、設定できるのはバイナリが実行可能な場合のみです（ <code class="docutils literal"><span class="pre">sh</span> <span class="pre">-c</span></code> が使われていない時のみ ）。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><em>exec</em> 形式は JSON 配列でパースされます。つまり、語句はシングルクォート(『)ではなく、ダブルクォート(「)で囲む必要があります。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><em>シェル</em> 形式とは異なり、 <em>exec</em> 形式はシェルを呼び出しません。つまり、通常のシェル上の処理はされません。例えば、 <code class="docutils literal"><span class="pre">ENTRYPOINT</span> <span class="pre">[&quot;echo&quot;,</span> <span class="pre">&quot;$HOME&quot;]</span></code> は <code class="docutils literal"><span class="pre">$HOME</span></code> を変数展開しません。シェル上の処理が必要であれば、 <em>シェル</em> 形式を使うか、シェルを直接実行します。例： <code class="docutils literal"><span class="pre">ENTRYPOINT</span> <span class="pre">[</span> <span class="pre">&quot;sh&quot;,</span> <span class="pre">&quot;-c&quot;,</span> <span class="pre">&quot;echo</span> <span class="pre">$HOME&quot;</span> <span class="pre">]</span></code>。変数は <code class="docutils literal"><span class="pre">Dockerfile</span></code> で <code class="docutils literal"><span class="pre">ENV</span></code> を使って定義することができ、 <code class="docutils literal"><span class="pre">Dockerfile</span></code> パーサー上で展開されます。</p>
</div>
</div>
<div class="section" id="id18">
<h3><a class="toc-backref" href="#id45">シェル形式の ENTRYPOINT 例</a><a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> に文字列を指定したら、 <code class="docutils literal"><span class="pre">/bin/sh</span> <span class="pre">-c</span></code> で実行されます。この形式はシェルの処理を使いますので、シェル上の環境変数を展開し、 <code class="docutils literal"><span class="pre">CMD</span></code> や <code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span></code> コマンド行の引数を無視します。 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">stop</span></code> で <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> で指定している実行ファイルにシグナルを送りたい場合は、 <code class="docutils literal"><span class="pre">exec</span></code> を使う必要があるのを思い出してください。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">ENTRYPOINT</span><span class="s"> exec top -b</span>
</pre></div>
</div>
<p>このイメージを実行したら、単一の <code class="docutils literal"><span class="pre">PID</span> <span class="pre">1</span></code> プロセスが表示されます。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker run -it --rm --name <span class="nb">test</span> top
Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached
CPU:   <span class="m">5</span>% usr   <span class="m">0</span>% sys   <span class="m">0</span>% nic  <span class="m">94</span>% idle   <span class="m">0</span>% io   <span class="m">0</span>% irq   <span class="m">0</span>% sirq
Load average: <span class="m">0</span>.08 <span class="m">0</span>.03 <span class="m">0</span>.05 <span class="m">2</span>/98 <span class="m">6</span>
  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
    <span class="m">1</span>     <span class="m">0</span> root     R     <span class="m">3164</span>   <span class="m">0</span>%   <span class="m">0</span>% top -b
</pre></div>
</div>
<p>終了するには、 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">stop</span></code> を実行します。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ /usr/bin/time docker stop <span class="nb">test</span>
<span class="nb">test</span>
real    0m <span class="m">0</span>.20s
user    0m <span class="m">0</span>.02s
sys 0m <span class="m">0</span>.04s
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> に <code class="docutils literal"><span class="pre">exec</span></code> を追加し忘れたとします。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">ENTRYPOINT</span><span class="s"> top -b</span>
<span class="k">CMD</span><span class="s"> --ignored-param1</span>
</pre></div>
</div>
<p>次のように実行します（次のステップで名前を使います）。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker run -it --name <span class="nb">test</span> top --ignored-param2
Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached
CPU:   <span class="m">9</span>% usr   <span class="m">2</span>% sys   <span class="m">0</span>% nic  <span class="m">88</span>% idle   <span class="m">0</span>% io   <span class="m">0</span>% irq   <span class="m">0</span>% sirq
Load average: <span class="m">0</span>.01 <span class="m">0</span>.02 <span class="m">0</span>.05 <span class="m">2</span>/101 <span class="m">7</span>
  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
    <span class="m">1</span>     <span class="m">0</span> root     S     <span class="m">3168</span>   <span class="m">0</span>%   <span class="m">0</span>% /bin/sh -c top -b cmd cmd2
    <span class="m">7</span>     <span class="m">1</span> root     R     <span class="m">3164</span>   <span class="m">0</span>%   <span class="m">0</span>% top -b
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">top</span></code> の出力から、 <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> が <code class="docutils literal"><span class="pre">PID</span> <span class="pre">1</span></code> ではないことが分かるでしょう。</p>
<p>それから <code class="docutils literal"><span class="pre">docker</span> <span class="pre">stop</span> <span class="pre">test</span></code> を実行しても、コンテナはすぐに終了しません。これは <code class="docutils literal"><span class="pre">stop</span></code> コマンドがタイムアウト後、<code class="docutils literal"><span class="pre">SIGKILL</span></code> を強制送信したからです。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it <span class="nb">test</span> ps aux
PID   USER     COMMAND
    <span class="m">1</span> root     /bin/sh -c top -b cmd cmd2
    <span class="m">7</span> root     top -b
    <span class="m">8</span> root     ps aux
$ /usr/bin/time docker stop <span class="nb">test</span>
<span class="nb">test</span>
real    0m <span class="m">10</span>.19s
user    0m <span class="m">0</span>.04s
sys 0m <span class="m">0</span>.03s
</pre></div>
</div>
</div>
</div>
<div class="section" id="cmd-entrypoint">
<span id="understand-how-cmd-and-entrypoint-interact"></span><h2><a class="toc-backref" href="#id46">CMD と ENTRYPOINT がどのように作用するか学ぶ</a><a class="headerlink" href="#cmd-entrypoint" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal"><span class="pre">CMD</span></code> と <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 命令はコンテナ起動時に実行するコマンドを定義します。両方を記述する時、動作には複数のルールがあります。</p>
<ol class="arabic simple">
<li>Dockerfile には少なくとも１つの <code class="docutils literal"><span class="pre">CMD</span></code> または <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 命令を含むべきです。</li>
</ol>
<ol class="arabic simple" start="2">
<li><code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> は実行可能なコンテナとして定義する時に使うべきです。</li>
</ol>
<ol class="arabic simple" start="3">
<li>コンテナをアドホック（その場その場）で実行するコマンドを <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> にする場合、そのデフォルトの引数の指定として <code class="docutils literal"><span class="pre">CMD</span></code> を指定すべきです。</li>
</ol>
<ol class="arabic simple" start="4">
<li><code class="docutils literal"><span class="pre">CMD</span></code> はコンテナ実行時に引数を指定すると上書します。</li>
</ol>
<p>以下の表は <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> / <code class="docutils literal"><span class="pre">CMD</span></code> を組み合わせたコマンドの実行結果です。</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">ENTRYPOINT なし</th>
<th class="head">ENTRYPOINT exec_entry p1_entry</th>
<th class="head">ENTRYPOINT [“exec_entry”, “p1_entry”]</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>CMD なし</strong></td>
<td>エラー。実行できない。</td>
<td>/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry</td>
</tr>
<tr class="row-odd"><td><strong>CMD [“exec_cmd”, “p1_cmd”]</strong></td>
<td>exec_cmd p1_cmd</td>
<td>/bin/sh -c exec_entry p1_entry exec_cmd p1_cmd</td>
<td>exec_entry p1_entry exec_cmd p1_cmd</td>
</tr>
<tr class="row-even"><td><strong>CMD [“p1_cmd”, “p2_cmd”]</strong></td>
<td>p1_cmd p2_cmd</td>
<td>/bin/sh -c exec_entry p1_entry p1_cmd p2_cmd</td>
<td>exec_entry p1_entry p1_cmd p2_cmd</td>
</tr>
<tr class="row-odd"><td><strong>CMD exec_cmd p1_cmd</strong></td>
<td>/bin/sh -c exec_cmd p1_cmd</td>
<td>/bin/sh -c exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd</td>
<td>exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="volume">
<span id="id19"></span><h2><a class="toc-backref" href="#id47">VOLUME</a><a class="headerlink" href="#volume" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">VOLUME</span><span class="s"> [&quot;/data&quot;]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">VOLUME</span></code> 命令は指定した名前でマウントポイントを作成し、他のホストやコンテナから外部マウント可能なボリュームにします。指定する値は <code class="docutils literal"><span class="pre">VOLUME</span> <span class="pre">[&quot;/var/log&quot;]</span></code> といったJSON 配列になるべきです。あるいは文字列で <code class="docutils literal"><span class="pre">VOLUME</span> <span class="pre">/var/log</span></code> や <code class="docutils literal"><span class="pre">VOLUME</span> <span class="pre">/var/log</span> <span class="pre">/var/db</span></code> のように、複数の引数を書くこともできます。Docker クライアントを使ったマウント命令や詳しい情報やサンプルは <a class="reference internal" href="../tutorials/dockervolumes.html#mount-a-host-directory-as-a-data-volume"><span class="std std-ref">ボリュームを経由してディレクトリを共有</span></a> をご覧ください。</p>
<p><code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span></code> コマンドは、ベース・イメージから指定した場所に、データを保存する場所として新規作成したボリュームを初期化します。例えば、次の Dockerfile をご覧ください。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">RUN</span> mkdir /myvol
<span class="k">RUN</span> <span class="nb">echo</span> <span class="s2">&quot;hello world&quot;</span> &gt; /myvol/greeting
<span class="k">VOLUME</span><span class="s"> /myvol</span>
</pre></div>
</div>
<p>この Dockerfile によって作られたイメージは、 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">run</span></code> を実行したら、新しいマウント・ポイント <code class="docutils literal"><span class="pre">/myvol</span></code> を作成し、<code class="docutils literal"><span class="pre">greeting</span></code> ファイルを直近で作成したボリュームにコピーします。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">構築ステップでボリューム内においてあらゆる変更を加えても、宣言後に内容は破棄されます。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">リストは JSON 配列でパースされます。これが意味するのは、単語はシングルクォート(『)で囲むのではなく、ダブルクォート(「)を使う必要があります。</p>
</div>
</div>
<div class="section" id="user">
<span id="id20"></span><h2><a class="toc-backref" href="#id48">USER</a><a class="headerlink" href="#user" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>USER daemon
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">USER</span></code> 命令セットはユーザ名か UID を使います。これはイメージを <code class="docutils literal"><span class="pre">RUN</span></code> 、 <code class="docutils literal"><span class="pre">CMD</span></code> 、 <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 命令で実行時のものであり、 <code class="docutils literal"><span class="pre">Dockerfile</span></code> で指定します。</p>
</div>
<div class="section" id="workdir">
<span id="id21"></span><h2><a class="toc-backref" href="#id49">WORKDIR</a><a class="headerlink" href="#workdir" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">WORKDIR</span><span class="s"> /path/to/workdir</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">WORKDIR</span></code> 命令セットは <code class="docutils literal"><span class="pre">Dockerfile</span></code> で <code class="docutils literal"><span class="pre">RUN</span></code> 、 <code class="docutils literal"><span class="pre">CMD</span></code> 、 <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> 、 <code class="docutils literal"><span class="pre">COPY</span></code> 、 <code class="docutils literal"><span class="pre">ADD</span></code> 命令実行時の作業ディレクトリ（working directory）を指定します。もし <code class="docutils literal"><span class="pre">WORKDIR</span></code> が存在しなければ、 <code class="docutils literal"><span class="pre">Dockerfile</span></code> 命令内で使用しなくてもディレクトリを作成します。</p>
<p>１つの <code class="docutils literal"><span class="pre">Dockerfile</span></code> で複数回の利用が可能です。パスを指定したら、 <code class="docutils literal"><span class="pre">WORKDIR</span></code> 命令は直前に指定した相対パスに切り替えます。例：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">WORKDIR</span><span class="s"> /a</span>
<span class="k">WORKDIR</span><span class="s"> b</span>
<span class="k">WORKDIR</span><span class="s"> c</span>
<span class="k">RUN</span> pwd
</pre></div>
</div>
<p>この <code class="docutils literal"><span class="pre">Dockerfile</span></code> を使えば、最後の <code class="docutils literal"><span class="pre">pwd</span></code> コマンドの出力は <code class="docutils literal"><span class="pre">/a/b/c</span></code> になります。</p>
<p><code class="docutils literal"><span class="pre">WORKDIR</span></code> 命令は <code class="docutils literal"><span class="pre">ENV</span></code> 命令を使った環境変数も展開できます。環境変数を使うには <code class="docutils literal"><span class="pre">Dockerfile</span></code> で明確に定義する必要があります。例：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">ENV</span><span class="s"> DIRPATH /path</span>
<span class="k">WORKDIR</span><span class="s"> $DIRPATH/$DIRNAME</span>
<span class="k">RUN</span> pwd
</pre></div>
</div>
<p>この <code class="docutils literal"><span class="pre">Dockerfile</span></code> を使えば、最後の <code class="docutils literal"><span class="pre">pwd</span></code> コマンドの出力は <code class="docutils literal"><span class="pre">/path/$DIRNAME</span></code> になります。</p>
</div>
<div class="section" id="arg">
<span id="id22"></span><h2><a class="toc-backref" href="#id50">ARG</a><a class="headerlink" href="#arg" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>ARG &lt;名前&gt;<span class="o">[=</span>&lt;デフォルト値&gt;<span class="o">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ARG</span></code> 命令は、構築時に作業者が <code class="docutils literal"><span class="pre">docker</span> <span class="pre">build</span></code> コマンドで使う変数、 <code class="docutils literal"><span class="pre">--build-arg</span> <span class="pre">&lt;変数名&gt;=&lt;値&gt;</span></code> フラグを定義するものです。ユーザが構築時に引数を指定しても Dockerfile で定義されていなければ、構築時に次のようなエラーが出ます。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>One or more build-args were not consumed, failing build.
</pre></div>
</div>
<p>Dockerfile の作者は <code class="docutils literal"><span class="pre">ARG</span></code> 変数を１度だけ定義するだけでなく、複数の <code class="docutils literal"><span class="pre">ARG</span></code> を指定可能です。有効な Dockerfile の例：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> busybox</span>
ARG user1
ARG buildno
...
</pre></div>
</div>
<p>Dockerfile の作者は、オプションで <code class="docutils literal"><span class="pre">ARG</span></code> 命令のデフォルト値を指定できます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> busybox</span>
ARG <span class="nv">user1</span><span class="o">=</span>someuser
ARG <span class="nv">buildno</span><span class="o">=</span><span class="m">1</span>
...
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ARG</span></code> がデフォルト値を持っている場合、構築時に値の指定が無ければ、このデフォルト値を使います。</p>
<p><code class="docutils literal"><span class="pre">ARG</span></code> 変数は <code class="docutils literal"><span class="pre">Dockerfile</span></code> で記述した行以降で効果があります。ただし、コマンドライン上で引数の指定が無い場合です。次の Dockerfile の例を見てみましょう。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> busybox</span>
USER <span class="si">${</span><span class="nv">user</span><span class="k">:-</span><span class="nv">some_user</span><span class="si">}</span>
ARG user
USER <span class="nv">$user</span>
...
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker build --build-arg <span class="nv">user</span><span class="o">=</span>what_user Dockerfile
</pre></div>
</div>
<p>２行めの <code class="docutils literal"><span class="pre">USER</span></code> は <code class="docutils literal"><span class="pre">some_user</span></code> を、３行めサブシーケントで定義された <code class="docutils literal"><span class="pre">user</span></code> 変数として評価します。４行めでは <code class="docutils literal"><span class="pre">what_user</span></code> を <code class="docutils literal"><span class="pre">USER</span></code> で定義したものと評価し、 <code class="docutils literal"><span class="pre">what_user</span></code> 値はコマンドラインで指定したものになります。 <code class="docutils literal"><span class="pre">ARG</span></code> 命令で定義するまで、あらゆる変数は空の文字列です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">構築時の変数として、GitHub の鍵やユーザの証明書などの秘密情報を含むのは、推奨される使い方ではありません。</p>
</div>
<p><code class="docutils literal"><span class="pre">ARG</span></code> や <code class="docutils literal"><span class="pre">ENV</span></code> 命令を <code class="docutils literal"><span class="pre">RUN</span></code> 命令のための環境変数にも利用できます。 <code class="docutils literal"><span class="pre">ENV</span></code> 命令を使った環境変数の定義は、常に同じ名前の <code class="docutils literal"><span class="pre">ARG</span></code> 命令を上書きします。Dockerfile における <code class="docutils literal"><span class="pre">ENV</span></code> と <code class="docutils literal"><span class="pre">ARG</span></code> 命令を考えましょう。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
ARG CONT_IMG_VER
<span class="k">ENV</span><span class="s"> CONT_IMG_VER v1.0.0</span>
<span class="k">RUN</span> <span class="nb">echo</span> <span class="nv">$CONT_IMG_VER</span>
</pre></div>
</div>
<p>それから、イメージを次のように起動します。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker build --build-arg <span class="nv">CONT_IMG_VER</span><span class="o">=</span>v2.0.1 Dockerfile
</pre></div>
</div>
<p>この例では、 <code class="docutils literal"><span class="pre">RUN</span></code> 命令は <code class="docutils literal"><span class="pre">v1.0.0</span></code> の代わりに、 <code class="docutils literal"><span class="pre">ARG</span></code> でユーザから渡された <code class="docutils literal"><span class="pre">v2.0.1</span></code> を使います。この動作はシェルスクリプトの挙動に似ています。ローカルのスコープにある環境変数が、与えられた引数や上位の環境変数によって上書きするようなものです。</p>
<p>上記の <code class="docutils literal"><span class="pre">ENV</span></code> 指定の他にも、更に <code class="docutils literal"><span class="pre">ARG</span></code> と <code class="docutils literal"><span class="pre">ENV</span></code> を使いやすくする指定も可能です。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
ARG CONT_IMG_VER
<span class="k">ENV</span><span class="s"> CONT_IMG_VER ${CONT_IMG_VER:-v1.0.0}</span>
<span class="k">RUN</span> <span class="nb">echo</span> <span class="nv">$CONT_IMG_VER</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ARG</span></code> 命令とは異なり、構築時の <code class="docutils literal"><span class="pre">ENV</span></code> 値は常に一定です。docker build で –build-arg フラグを使わない場合を考えてみましょう。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ docker build Dockerfile
</pre></div>
</div>
<p>この Dockerfile の例では、 <code class="docutils literal"><span class="pre">CONT_IMG_VER</span></code> はイメージの中では変わりませんが、３行めの <code class="docutils literal"><span class="pre">ENV</span></code> 命令でデフォルト値を設定することにより、値は <code class="docutils literal"><span class="pre">v1.0.0</span></code> となります。</p>
<p>この例における変数展開のテクニックは、コマンドラインから引数を渡せるようにし、 <code class="docutils literal"><span class="pre">ENV</span></code> 命令を使うことで最終的に一貫したイメージを作成します。サポートされている変数展開は <a class="reference internal" href="#environment-replacement"><span class="std std-ref">Dockerfile 命令の一部</span></a> のみです。</p>
<p>Docker は Dockerfile に対応する <code class="docutils literal"><span class="pre">ARG</span></code> 命令が無くても、既定の <code class="docutils literal"><span class="pre">ARG</span></code> 変数セットを持っています。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HTTP_PROXY</span></code></li>
<li><code class="docutils literal"><span class="pre">http_proxy</span></code></li>
<li><code class="docutils literal"><span class="pre">HTTPS_PROXY</span></code></li>
<li><code class="docutils literal"><span class="pre">https_proxy</span></code></li>
<li><code class="docutils literal"><span class="pre">FTP_PROXY</span></code></li>
<li><code class="docutils literal"><span class="pre">ftp_proxy</span></code></li>
<li><code class="docutils literal"><span class="pre">NO_PROXY</span></code></li>
<li><code class="docutils literal"><span class="pre">no_proxy</span></code></li>
</ul>
<p>これらを使うには、コマンドラインで <code class="docutils literal"><span class="pre">--build-arg</span> <span class="pre">&lt;変数名&gt;=&lt;値&gt;</span></code> フラグを単に渡すだけです。</p>
<div class="section" id="impact-on-build-caching">
<span id="id23"></span><h3><a class="toc-backref" href="#id51">構築キャッシュの影響</a><a class="headerlink" href="#impact-on-build-caching" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">ARG</span></code> 変数は、イメージ構築時の <code class="docutils literal"><span class="pre">ENV</span></code> 変数のように残り続けません。しかし、 <code class="docutils literal"><span class="pre">ARG</span></code> 変数は構築キャッシュで似たような方法として扱えます。もし Dockerfile で <code class="docutils literal"><span class="pre">ARG</span></code> 変数を定義したら、この値が以前の値と違う時は、以降で <code class="docutils literal"><span class="pre">ARG</span></code> 変数が出た時「キャッシュ・ミス」を発生します。これは、値を定義していなくても発生します。特に、すべての <code class="docutils literal"><span class="pre">RUN</span></code> 命令は <code class="docutils literal"><span class="pre">ARG</span></code> 変数を（環境変数から）暗黙的に使おうとするため、結果としてキャッシュ・ミスを引き起こします。</p>
<p>たとえば、２つの Dockerfile を考えます。</p>
<div class="highlight-dockerfile"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
ARG CONT_IMG_VER
<span class="k">RUN</span> <span class="nb">echo</span> <span class="nv">$CONT_IMG_VER</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-dockerfile"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
ARG CONT_IMG_VER
<span class="k">RUN</span> <span class="nb">echo</span> hello
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal"><span class="pre">--build-arg</span> <span class="pre">CONT_IMG_VER=&lt;値&gt;</span></code> をコマンドライン上で指定すると、どちらの場合も２行目はキャッシュ・ミスを引き起こします。さらに３行目もキャッシュ・ミスになります。 <code class="docutils literal"><span class="pre">ARG</span> <span class="pre">CONT_IMG_VER</span></code> は RUN 行で <code class="docutils literal"><span class="pre">CONT_IMG_VER=&lt;値&gt;</span></code> で echo hello と同じにしたいのであれば、 <code class="docutils literal"><span class="pre">&lt;値&gt;</span></code> の編億がキャッシュ・ミスになります。</p>
<p>同じコマンド行で別の例を考えます。</p>
<div class="highlight-dockerfile"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
ARG CONT_IMG_VER
<span class="k">ENV</span><span class="s"> CONT_IMG_VER $CONT_IMG_VER</span>
<span class="k">RUN</span> <span class="nb">echo</span> <span class="nv">$CONT_IMG_VER</span>
</pre></div>
</td></tr></table></div>
<p>この例では、キャッシュミスが３行めで発生します。ミスが起こるのは <code class="docutils literal"><span class="pre">ENV</span></code> 変数が <code class="docutils literal"><span class="pre">ARG</span></code> 変数を参照しているのと、この変数がコマンドラインで変わるためです。例における <code class="docutils literal"><span class="pre">ENV</span></code> コマンドはイメージの中で処理されるものです。</p>
<p>もし <code class="docutils literal"><span class="pre">ENV</span></code> 命令を同じ名前の <code class="docutils literal"><span class="pre">ARG</span></code> 命令で、次のように上書きしたらどうでしょう。</p>
<div class="highlight-dockerfile"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> ubuntu</span>
ARG CONT_IMG_VER
<span class="k">ENV</span><span class="s"> CONT_IMG_VER hello</span>
<span class="k">RUN</span> <span class="nb">echo</span> <span class="nv">$CONT_IMG_VER</span>
</pre></div>
</td></tr></table></div>
<p>３行めはキャッシュミスを引き起こしません。 <code class="docutils literal"><span class="pre">CONT_IMG_VAR</span></code> は固定（ <code class="docutils literal"><span class="pre">hello</span></code> ）だからです。そのため、環境変数と値は <code class="docutils literal"><span class="pre">RUN</span></code>  （４行め）で使われますが、構築時に変わりません。</p>
</div>
</div>
<div class="section" id="onbuild">
<span id="id24"></span><h2><a class="toc-backref" href="#id52">ONBUILD</a><a class="headerlink" href="#onbuild" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>ONBUILD <span class="o">[</span>命令<span class="o">]</span>
</pre></div>
</div>
<p>イメージは他で構築したイメージを元にしている時、<code class="docutils literal"><span class="pre">ONBUILD</span></code> 命令はイメージに対して最終的に実行する <em>トリガ</em> 命令を追加します。トリガは構築後に行うもので、 <code class="docutils literal"><span class="pre">Dockerfile</span></code> で <code class="docutils literal"><span class="pre">FROM</span></code> 命令のあとに書くことができます。</p>
<p>あらゆる構築時の命令をトリガとして登録可能です。</p>
<p>これは他のイメージからイメージを構築する時に役立つでしょう。例えば、アプリケーションの開発環境やデーモンは、ユーザごとに設定をカスタマイズする可能性があります。</p>
<p>例えば、イメージが Python アプリケーション・ビルダーを再利用する時、アプリケーションのソースコードを適切なディレクトリに追加し、その後、構築スクリプトを実行することもあるでしょう。この時点では <code class="docutils literal"><span class="pre">ADD</span></code> と <code class="docutils literal"><span class="pre">RUN</span></code> を呼び出せません。なぜなら、まだアプリケーションのソースコードにアクセスしておらず、個々のアプリケーション構築によって異なるからです。アプリケーションの開発者は、ボイラープレートである <code class="docutils literal"><span class="pre">Dockerfile</span></code> をコピーペーストでアプリケーションを入れるように編集するだけです。ですが、これは効率的ではなく、エラーを引き起こしやすく、アプリケーション固有のコードが混在することで更新が大変になります。</p>
<p>この解決方法として、 <code class="docutils literal"><span class="pre">ONBUILD</span></code> を使い、実行後に別の構築ステージに進む上位命令を登録することです。</p>
<p>これは次のように動作します。</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">ONBUILD</span></code> 命令が呼び出されると、ビルダーはイメージ構築時のメタデータの中にトリガを追加します。</li>
</ol>
<ol class="arabic simple" start="2">
<li>構築が完了したら、全てのトリガはイメージのマニフェスト内の  <code class="docutils literal"><span class="pre">OnBuild</span></code> キー配下に保管されます。この構築時点では、命令は何ら影響を与えません。</li>
</ol>
<ol class="arabic simple" start="3">
<li>このイメージは後で何らかのイメージの元になります。その時は <code class="docutils literal"><span class="pre">FROM</span></code> 命令で呼び出されます。 <code class="docutils literal"><span class="pre">FROM</span></code> 命令の処理の一部として、ダウンストリームのビルダーは <code class="docutils literal"><span class="pre">ONBULID</span></code> トリガを探し、登録された順番で実行します。もしトリガが失敗したら、 <code class="docutils literal"><span class="pre">FROM</span></code> 命令は処理を中断し、ビルドを失敗とします。もし全てのトリガが成功したら、 <code class="docutils literal"><span class="pre">FROM</span></code> 命令は完了し、以降は通常の構築が進みます。</li>
</ol>
<ol class="arabic simple" start="4">
<li>実行する前に、最終的なイメージ上からトリガが削除されます。言い替えると構築された「孫」には、何ら親子関係がありません。</li>
</ol>
<p>次のような例の記述を追加するでしょう。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="o">[</span>...<span class="o">]</span>
<span class="n n-Keyword">ONBUILD</span><span class="w"> </span><span class="k">ADD</span> . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><code class="docutils literal"><span class="pre">ONBUILD</span> <span class="pre">ONBUILD</span></code> 命令を使って <code class="docutils literal"><span class="pre">ONBULID</span></code> 命令の上書きはできません。</p>
</div>
</div>
<div class="section" id="stopsignal">
<span id="id25"></span><h2><a class="toc-backref" href="#id53">STOPSIGNAL</a><a class="headerlink" href="#stopsignal" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>STOPSIGNAL シグナル
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">STOPSIGNAL</span></code> 命令は、コンテナを終了する時に送信するための、システム・コール・シグナルを設定します。シグナルはカーネルの syscall テーブルと一致する、有効な番号の必要があります。例えば、9 あるいはシグナル名 SIGNAME や、 SIGKILL などです。</p>
</div>
<div class="section" id="healthcheck">
<span id="build-healthcheck"></span><h2><a class="toc-backref" href="#id54">HEALTHCHECK</a><a class="headerlink" href="#healthcheck" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal"><span class="pre">HEALTHCHECK</span></code> 命令は２つの形式があります：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">HEALTHCHECK</span> <span class="pre">[オプション]</span> <span class="pre">CMD</span> <span class="pre">コマンド</span></code> （コンテナ内でコマンドを実行して、コンテナの正常性を確認）</li>
<li><code class="docutils literal"><span class="pre">HEALTHCHECK</span> <span class="pre">NONE</span></code>  （ベース・イメージからのヘルスチェック継承を無効化）</li>
</ul>
<p><code class="docutils literal"><span class="pre">HEALTHCHECK</span></code> 命令は、 Docker に対してコンテナの正常性をどのように確認（テスト）するかを伝えます。これはウェブ・サーバがループで塞がってしまい、新しい接続を受け付けられないような状態を検出できます。サーバプロセスが実行中でも、応答が無ければ検出します。</p>
<p>コンテナのヘルスチェック（healthcheck）を有効化すると、通常の状態に加え、ヘルス・ステータス（health status）を追加します。こちらの初期ステータスは <code class="docutils literal"><span class="pre">starting</span></code> （起動中）です。ヘルスチェックが正常であれば、ステータスは（以前の状態にかかわらず） <code class="docutils literal"><span class="pre">healthy</span></code> （正常）になります。特定回、連続して失敗したら、ステータスは <code class="docutils literal"><span class="pre">unhealthy</span></code>  （異常）になります。</p>
<p><code class="docutils literal"><span class="pre">CMD</span></code> より前に記述するオプションは、以下の通りです。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">--interval=間隔</span></code> (デフォルト: 30s)</li>
<li><code class="docutils literal"><span class="pre">--timeout=間隔</span></code> (デフォルト: 30s)</li>
<li><code class="docutils literal"><span class="pre">--retries=N</span></code>  (デフォルト: 3)</li>
</ul>
<p>ヘルス・チェックは、まず最初の <strong>interval</strong> （間隔）秒の後、コンテナを起動します。そして <strong>interval</strong> 秒後に直近の確認を行います。</p>
<p>確認に <strong>timeout</strong> （タイムアウト）秒を越えるようであれば、確認は失敗とみなします。</p>
<p>コンテナに対するヘルスチェックが連続して失敗したら、コンテナは <code class="docutils literal"><span class="pre">unhealthy</span></code> とみなします。</p>
<p>これらの処理は <code class="docutils literal"><span class="pre">Dockerfile</span></code> で命令がある場合のみです。複数の <code class="docutils literal"><span class="pre">HEALTHCHECK</span></code> があれば、最後の１つだけ有効です。</p>
<p><code class="docutils literal"><span class="pre">CMD</span></code> キーワード後のコマンドは、シェル・コマンド（例： <code class="docutils literal"><span class="pre">HEALTHCHECK</span> <span class="pre">CMD</span> <span class="pre">/bin/check-running</span></code> ）あるいは exec 配列（こちらは Dockerfile の他コマンドと同様です。例えば <code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> の詳細をご覧ください ）です。</p>
<p>コマンドはコンテナのヘルス・ステータスの終了コードを検出できます。値は以下の通りです。</p>
<ul class="simple">
<li>0: success（成功） - コンテナは正常であり、使う準備が整っています</li>
<li>1: unhealthy（障害） - コンテナは正常に動作していません</li>
<li>2: starting（起動中） - まだコンテナの利用準備が整っていませんが、正常に動作しています</li>
</ul>
<p>監視結果が 2（」starting」）であれば、コンテナは起動しはじめており「起動中」の状態であり、「unhealthy」状態ではありません。</p>
<p>たとえば、５分ごとにウエブ・サーバがサイトのメインページを３秒以内に表示するかどうかを確認するには、次のように指定します。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>HEALTHCHECK --interval<span class="o">=</span>5m --timeout<span class="o">=</span>3s <span class="se">\</span>
  CMD curl -f http://localhost/ <span class="o">||</span> <span class="nb">exit</span> <span class="m">1</span>
</pre></div>
</div>
<p>監視失敗時はデバッグしやすくなるように、コマンド実行時の標準出力や標準エラー出力といった、あらゆる出力テキスト（UTF-8 エンコード）はヘルス・ステータスに格納され、 <code class="docutils literal"><span class="pre">docker</span> <span class="pre">inspect</span></code> で確認可能です。この出力結果は短くして保存されます（現時点では始めから 4096 バイトのみ保存）。</p>
<p>コンテナのヘルス・ステータスが変われば、 <code class="docutils literal"><span class="pre">health_status</span></code> イベントが新しいステータスを生成します。</p>
<p><code class="docutils literal"><span class="pre">HEALTHCHECK</span></code>  機能は Docker 1.12 で追加されました。</p>
</div>
<div class="section" id="shell">
<span id="builder-shell"></span><h2><a class="toc-backref" href="#id55">SHELL</a><a class="headerlink" href="#shell" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>SHELL <span class="o">[</span><span class="s2">&quot;実行可能なファイル&quot;</span>, <span class="s2">&quot;パラメータ&quot;</span><span class="o">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">SHELL</span></code> 命令は、シェル形式でコマンド実行時における、デフォルトのシェルを上書きします。 Linux 上でのデフォルトのシェルは <code class="docutils literal"><span class="pre">[&quot;/bin/sh&quot;,</span> <span class="pre">&quot;-c&quot;]</span></code> です。Windows は <code class="docutils literal"><span class="pre">[&quot;cmd&quot;,</span> <span class="pre">&quot;/S&quot;,</span> <span class="pre">&quot;/C&quot;]</span></code> です。 <code class="docutils literal"><span class="pre">SHELL</span></code> 命令は Dockerfile で JSON 形式での記述が必要です。</p>
<p><code class="docutils literal"><span class="pre">SHELL</span></code> 命令はとりわけ Windows で便利です。全く異なるネイティブなシェル <code class="docutils literal"><span class="pre">cmd</span></code> と <code class="docutils literal"><span class="pre">powershell</span></code>  だけでなく、代わりのシェルとして <code class="docutils literal"><span class="pre">sh</span></code> も指定できます。</p>
<p><code class="docutils literal"><span class="pre">SHELL</span></code> 命令は複数回指定できます。 <code class="docutils literal"><span class="pre">SHELL</span></code> 命令ごとに、これまでの <code class="docutils literal"><span class="pre">SHELL</span></code> 命令を上書きし、以降の命令全てに反映します。例：</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="k">FROM</span><span class="s"> windowsservercore</span>

<span class="c"># cmd /S /C echo default として実行する</span>
<span class="k">RUN</span> <span class="nb">echo</span> default

<span class="c"># cmd /S /C powershell -command Write-Host default として実行する</span>
<span class="k">RUN</span> powershell -command Write-Host default

<span class="c"># powershell -command Write-Host hello として実行する</span>
SHELL <span class="o">[</span><span class="s2">&quot;powershell&quot;</span>, <span class="s2">&quot;-command&quot;</span><span class="o">]</span>
<span class="k">RUN</span> Write-Host hello

<span class="c"># cmd /S /C echo hello として実行する</span>
SHELL <span class="o">[</span><span class="s2">&quot;cmd&quot;</span>, <span class="s2">&quot;/S&quot;&quot;, &quot;</span>/C<span class="s2">&quot;]</span>
<span class="k">RUN</span> <span class="nb">echo</span> hello
</pre></div>
</div>
<p>Dockerfile の <code class="docutils literal"><span class="pre">RUN</span></code>  、 <code class="docutils literal"><span class="pre">CMD</span></code> 、<code class="docutils literal"><span class="pre">ENTRYPOINT</span></code> のシェルは、 <code class="docutils literal"><span class="pre">SHELL</span></code> 命令以後にあれば影響を受けます。</p>
<p>次の例は Windows で一般的に見受けられるパターンですが、 <code class="docutils literal"><span class="pre">SHELL</span></code> 命令で簡素化できます。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>...
<span class="k">RUN</span> powershell -command Execute-MyCmdlet -param1 <span class="s2">&quot;c:\foo.txt&quot;</span>
...
</pre></div>
</div>
<p>このコマンドは、Docker によって次のように処理されます。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>cmd /S /C powershell -command Execute-MyCmdlet -param1 <span class="s2">&quot;c:\foo.txt&quot;</span>
</pre></div>
</div>
<p>これが非効率なのは、２つの理由があります。１つは不要な cmd.exe プロセッサ（いわゆるシェル）が呼び出されること。もう１つは各 <code class="docutils literal"><span class="pre">RUN</span></code> 命令ごとに追加の <code class="docutils literal"><span class="pre">powershell</span> <span class="pre">-command</span></code> コマンドが実行されるためです。</p>
<p>効率的にするには、２つの仕組みを採用します。１つは RUN 命令を次のように JSON 形式で使います。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span>...
<span class="k">RUN</span> <span class="o">[</span><span class="s2">&quot;powershell&quot;</span>, <span class="s2">&quot;-command&quot;</span>, <span class="s2">&quot;Execute-MyCmdlet&quot;</span>, <span class="s2">&quot;-param1 \&quot;c:\\foo.txt\&quot;&quot;</span><span class="o">]</span>
...
</pre></div>
</div>
<p>JSON 形式は明確なものであり、不確実な cmd.exe を使いません。そのため、JSON 形式はダブル・クォートで囲み、エスケープするといった冗長な記述が必要です。他の方法としては、 <code class="docutils literal"><span class="pre">SHELL</span></code> 命令でシェル形式を使えば、Windows 利用者にとっても自然な構文になります。 <code class="docutils literal"><span class="pre">escape</span></code> パーサ・ディレクティブと一緒に使えば尚更です。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># escape=`</span>

<span class="k">FROM</span><span class="s"> windowsservercore</span>
SHELL <span class="o">[</span><span class="s2">&quot;powershell&quot;</span>,<span class="s2">&quot;-command&quot;</span><span class="o">]</span>
<span class="k">RUN</span> New-Item -ItemType Directory C:<span class="se">\E</span>xample
<span class="k">ADD</span><span class="s"> Execute-MyCmdlet.ps1 c:\example\</span>
<span class="k">RUN</span> c:<span class="se">\e</span>xample<span class="se">\E</span>xecute-MyCmdlet -sample <span class="s1">&#39;hello world&#39;</span>
</pre></div>
</div>
<p>実行結果：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>PS E:<span class="se">\d</span>ocker<span class="se">\b</span>uild<span class="se">\s</span>hell&gt; docker build -t shell .
Sending build context to Docker daemon <span class="m">3</span>.584 kB
Step <span class="m">1</span> : FROM windowsservercore
 ---&gt; 5bc36a335344
Step <span class="m">2</span> : SHELL powershell -command
 ---&gt; Running in 87d7a64c9751
 ---&gt; 4327358436c1
Removing intermediate container 87d7a64c9751
Step <span class="m">3</span> : RUN New-Item -ItemType Directory C:<span class="se">\E</span>xample
 ---&gt; Running in 3e6ba16b8df9


    Directory: C:<span class="se">\</span>


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----         <span class="m">6</span>/2/2016   <span class="m">2</span>:59 PM                Example


 ---&gt; 1f1dfdcec085
Removing intermediate container 3e6ba16b8df9
Step <span class="m">4</span> : ADD Execute-MyCmdlet.ps1 c:<span class="se">\e</span>xample<span class="se">\</span>
 ---&gt; 6770b4c17f29
Removing intermediate container b139e34291dc
Step <span class="m">5</span> : RUN c:<span class="se">\e</span>xample<span class="se">\E</span>xecute-MyCmdlet -sample <span class="s1">&#39;hello world&#39;</span>
 ---&gt; Running in abdcf50dfd1f
Hello from Execute-MyCmdlet.ps1 - passed hello world
 ---&gt; ba0e25255fda
Removing intermediate container abdcf50dfd1f
Successfully built ba0e25255fda
PS E:<span class="se">\d</span>ocker<span class="se">\b</span>uild<span class="se">\s</span>hell&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">SHELL</span></code> 命令はシェルの実行者でも変更できます。たとえば Windows 上で <code class="docutils literal"><span class="pre">SHELL</span> <span class="pre">cmd</span> <span class="pre">/S</span> <span class="pre">/C</span> <span class="pre">/V:ON|OFF</span></code> を使うと、環境変数の遅延拡張セマンティクス（delayed environment variable expansion semantics）を変更できます。</p>
<p><code class="docutils literal"><span class="pre">SHELL</span></code> 命令は Linux 上でも利用できます。 <code class="docutils literal"><span class="pre">zsh</span></code> 、 <code class="docutils literal"><span class="pre">csh</span></code> 、<code class="docutils literal"><span class="pre">tcsh</span></code>  など別のシェルを指定できます。</p>
<p><code class="docutils literal"><span class="pre">SHELL</span></code> 機能は Docker 1.12 で追加されました。</p>
</div>
<div class="section" id="id26">
<h2><a class="toc-backref" href="#id56">Dockerfile の例</a><a class="headerlink" href="#id26" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下で Dockerfile 構文の例を参照できます。実際の環境に興味があれば、 <a class="reference internal" href="../examples/index.html"><span class="doc">Docker 化の例</span></a> をご覧ください。</p>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># Nginx</span>
<span class="c">#</span>
<span class="c"># VERSION               0.0.1</span>

<span class="k">FROM</span><span class="s">      ubuntu</span>
<span class="k">MAINTAINER</span><span class="s"> Victor Vieux &lt;victor@docker.com&gt;</span>

LABEL <span class="nv">Description</span><span class="o">=</span><span class="s2">&quot;This image is used to start the foobar executable&quot;</span> <span class="nv">Vendor</span><span class="o">=</span><span class="s2">&quot;ACME Products&quot;</span> <span class="nv">Version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span>
<span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> apt-get install -y inotify-tools nginx apache2 openssh-server
</pre></div>
</div>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># Firefox over VNC</span>
<span class="c">#</span>
<span class="c"># VERSION               0.3</span>

<span class="k">FROM</span><span class="s"> ubuntu</span>

<span class="c"># 「フェイク」（偽）のディスプレイ用の vnc, xvfb と firefox をインストール</span>
<span class="k">RUN</span> apt-get update <span class="o">&amp;&amp;</span> apt-get install -y x11vnc xvfb firefox
<span class="k">RUN</span> mkdir ~/.vnc
<span class="c"># パスワードをセットアップ</span>
<span class="k">RUN</span> x11vnc -storepasswd <span class="m">1234</span> ~/.vnc/passwd
<span class="c"># firefox の自動起動（ベストな方法ではありませんが、動きます）</span>
<span class="k">RUN</span> bash -c <span class="s1">&#39;echo &quot;firefox&quot; &gt;&gt; /.bashrc&#39;</span>

<span class="k">EXPOSE</span><span class="s"> 5900</span>
<span class="k">CMD</span><span class="s">    [&quot;x11vnc&quot;, &quot;-forever&quot;, &quot;-usepw&quot;, &quot;-create&quot;]</span>
</pre></div>
</div>
<div class="highlight-dockerfile"><div class="highlight"><pre><span></span><span class="c"># 複数のイメージ例</span>
<span class="c">#</span>
<span class="c"># VERSION               0.1</span>

<span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">RUN</span> <span class="nb">echo</span> foo &gt; bar
<span class="c"># 「===&gt; 907ad6c2736f」 のような出力があります</span>

<span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">RUN</span> <span class="nb">echo</span> moo &gt; oink
<span class="c"># 「===&gt; 695d7793cbe4」 のような出力があります</span>

<span class="c"># You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span>
<span class="c"># /oink.</span>
<span class="c"># これで２つのイメージができました。</span>
<span class="c"># /bar がある 907ad6c2736f と、/oink がある 695d7793cbe4 です</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt>Dockerfile reference</dt>
<dd><a class="reference external" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></dd>
</dl>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="run.html" class="btn btn-neutral float-right" title="Docker run リファレンス" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Engine リファレンス" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, Docker Docs Translation Ja-Jp Project.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'17.06.Beta',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>